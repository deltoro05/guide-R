[
  {
    "objectID": "index.html#préface",
    "href": "index.html#préface",
    "title": "guide-R",
    "section": "Préface",
    "text": "Préface\n\n\n\n\n\n\nSite en construction\n\n\n\nLe présent site est en cours de construction et sera complété dans les prochains mois.\nEn attendant, nous vous conseillons de consulter le site analyse-R.\n\n\nCe guide porte sur l’analyse de données d’enquêtes avec le logiciel R, un logiciel libre de statitistiques et de traitement de données. Les exemples présentés ici relèvent principalement du champs des sciences sociales quantitatives et des sciences de santé. Ils peuvent néanmoins s’appliquer à d’autre champs disciplinaires. Cependant, comme tout ouvrage, ce guide ne peut être exhaustif.\nCe guide présente comment réaliser des analyses statistiques et diverses opérations courantes (comme la manipulation de données ou la production de graphiques) avec R. Il ne s’agit pas d’un cours de statistiques : les différents chapitres présupposent donc que vous avez déjà une connaissance des différentes techniques présentées. Si vous souhaitez des précisions théoriques / méthodologiques à propos d’un certain type d’analyses, nous vous conseillons d’utiliser votre moteur de recherche préféré. En effet, on trouve sur internet de très nombreux supports de cours (sans compter les nombreux ouvrages spécialisés disponibles en librairie).\nDe même, il ne s’agit pas d’une introduction ou d’un guide pour les utilisatrices et utilisateurs débutant·es. Si vous découvrez R, nous vous conseillons la lecture de l’Introduction à R et au tidyverse de Julien Barnier (https://juba.github.io/tidyverse/). Vous pouvez également lire les chapitres introductifs d’analyse-R : Introduction à l’analyse d’enquêtes avec R et RStudio (https://larmarange.github.io/analyse-R/). Néanmoins, quelques rappels sur les bases du langage sont fournis dans la section Bases du langage. Une bonne compréhension de ces dernières, bien qu’un peu ardue de prime abord, permet de comprendre le sens des commandes qu’on utilise et de pleinement exploiter la puissance que R offre en matière de manipulation de données.\nR disposent de nombreuses extensions ou packages (plus de 16 000) et il existe souvent plusieurs manières de procéder pour arriver au même résultat. En particulier, en matière de manipulation de données, on oppose1 souvent base R qui repose sur les fonctions disponibles en standard dans R, la majorité étant fournies dans les packages {base}, {utils} ou encore {stats}, qui sont toujours chargés par défaut, et le tidyverse qui est une collection de packages comprenant, entre autres, dplyr, tibble, tidyr, forcats ou encore ggplot2. Il y a un débat ouvert, parfois passionné, sur le fait de privilégier l’une ou l’autre approche, et les avantages et inconvénients de chacune dépendent de nombreux facteurs, comme la lisibilité du code ou bien les performances en temps de calcul. Dans ce guide, nous avons adopté un point de vue pragmatique et utiliserons, le plus souvent mais pas exclusivement, les fonctions du tidyverse, de même que nous avons privilégié d’autres packages, comme gtsummary ou questionr par exemple pour la statistique descriptive. Cela ne signifie pas, pour chaque point abordé, qu’il s’agit de l’unique manière de procéder. Dans certains cas, il s’agit simplement de préférences personnelles.1 Une comparaison des deux syntaxes est illustrée par une vignette dédiée de dplyr.\nBien qu’il en reprenne de nombreux contenus, ce guide ne se substitue pas au site analyse-R. Il s’agit plutôt d’une version complémentaire qui a vocation à être plus structurée et parfois plus sélective dans les contenus présentés.\nEn complément, on pourra également se référer aux webin-R, une série de vidéos avec partage d’écran, librement accessibles sur Youtube : https://www.youtube.com/c/webinR.\nCette version du guide a utilisé R version 4.2.1 (2022-06-23 ucrt). Ce document est généré avec quarto et le code source est disponible sur GitHub. Pour toute suggestion ou correction, vous pouvez ouvrir un ticket GitHub. Pour d’autres questions, vous pouvez utiliser les forums de discussion disponibles en bas de chaque page sur la version web du guide. Ce document est régulièrement mis à jour. La dernière version est consultable sur https://larmarange.github.io/guide-R/."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "guide-R",
    "section": "Remerciements",
    "text": "Remerciements\nCe document a bénéficié de différents apports provenant notamment de l’Introduction à R et de l’Introduction à R et au tidyverse de Julien Barnier et d’analyse-R : introduction à l’analyse d’enquêtes avec R et RStudio.\nMerci donc à Julien Barnier, Julien Biaudet, François Briatte, Milan Bouchet-Valat, Ewen Gallic, Frédérique Giraud, Joël Gombin, Mayeul Kauffmann, Christophe Lalanne & Nicolas Robette."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "guide-R",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International."
  },
  {
    "objectID": "bases/packages.html",
    "href": "bases/packages.html",
    "title": "1  Packages",
    "section": "",
    "text": "L’installation par défaut du logiciel R contient le cœur du programme ainsi qu’un ensemble de fonctions de base fournissant un grand nombre d’outils de traitement de données et d’analyse statistiques.\nR étant un logiciel libre, il bénéficie d’une forte communauté d’utilisateurs qui peuvent librement contribuer au développement du logiciel en lui ajoutant des fonctionnalités supplémentaires. Ces contributions prennent la forme d’extensions (packages en anglais) pouvant être installées par l’utilisateur et fournissant alors diverses fonctionnalités supplémentaires.\nIl existe un très grand nombre d’extensions (plus de 16 000 à ce jour), qui sont diffusées par un réseau baptisé CRAN (Comprehensive R Archive Network).\nLa liste de toutes les extensions disponibles sur CRAN est disponible ici : http://cran.r-project.org/web/packages/.\nPour faciliter un peu le repérage des extensions, il existe un ensemble de regroupements thématiques (économétrie, finance, génétique, données spatiales…) baptisés Task views : http://cran.r-project.org/web/views/.\nOn y trouve notamment une Task view dédiée aux sciences sociales, listant de nombreuses extensions potentiellement utiles pour les analyses statistiques dans ce champ disciplinaire : http://cran.r-project.org/web/views/SocialSciences.html.\nOn peut aussi citer le site Awesome R (https://github.com/qinwf/awesome-R) qui fournit une liste d’extensions choisies et triées par thématique."
  },
  {
    "objectID": "bases/packages.html#installation-cran",
    "href": "bases/packages.html#installation-cran",
    "title": "1  Packages",
    "section": "\n1.1 Installation (CRAN)",
    "text": "1.1 Installation (CRAN)\nL’installation d’une extension se fait par la fonction install.packages(), à qui on fournit le nom de l’extension. Par exemple, si on souhaite installer l’extension gtsummary :\n\ninstall.packages(\"gtsummary\")\n\nSous RStudio, on pourra également cliquer sur Install dans l’onglet Packages du quadrant inférieur droit.\nAlternativement, on pourra avoir recours au package remotes et à sa fonction remotes::install_cran() :\n\nremotes::install_cran(\"gtsummary\")\n\n\n\n\n\n\n\nNote\n\n\n\nLe package remotes n’est pas disponible par défaut sous R et devra donc être installé classiquement avec install.packages(\"remotes\"). À la différence de install.packages(), remotes::install_cran() vérifie si le package est déjà installé et, si oui, si la version installée est déjà la dernière version, avant de procéder à une installation complète si et seulement si cela est nécessaire."
  },
  {
    "objectID": "bases/packages.html#chargement",
    "href": "bases/packages.html#chargement",
    "title": "1  Packages",
    "section": "\n1.2 Chargement",
    "text": "1.2 Chargement\nUne fois un package installé (c’est-à-dire que ses fichiers ont eté téléchargés et copiés sur votre ordinateur), ses fonctions et objets ne sont pas directement accessibles. Pour pouvoir les utiliser, il faut, à chaque session de travail, charger le package en mémoire avec la fonction library() ou la fonction require() :\n\nlibrary(gtsummary)\n\nÀ partir de là, on peut utiliser les fonctions de l’extension, consulter leur page d’aide en ligne, accéder aux jeux de données qu’elle contient, etc.\nAlternativement, pour accéder à un objet ou une fonction d’un package sans avoir à le charger en mémoire, on pourra avoir recours à l’opérateur ::. Ainsi, l’écriture p::f() signifie la fonction f() du package p. Cette écriture sera notamment utilisée tout au long de ce guide pour indiquer à quel package appartient telle fonction : remotes::install_cran() indique que la fonction install_cran() provient du packages remotes.\n\n\n\n\n\n\nImportant\n\n\n\nIl est important de bien comprendre la différence entre install.packages() et library(). La première va chercher un package sur internet et l’installe en local sur le disque dur de l’ordinateur. On n’a besoin d’effectuer cette opération qu’une seule fois. La seconde lit les informations de l’extension sur le disque dur et les met à disposition de R. On a besoin de l’exécuter à chaque début de session ou de script."
  },
  {
    "objectID": "bases/packages.html#mise-à-jour",
    "href": "bases/packages.html#mise-à-jour",
    "title": "1  Packages",
    "section": "\n1.3 Mise à jour",
    "text": "1.3 Mise à jour\nPour mettre à jour l’ensemble des pacakges installés, il suffit d’exécuter la fonction update.packages() :\n\nupdate.packages()\n\nSous RStudio, on pourra alternativement cliquer sur Update dans l’onglet Packages du quadrant inférieur droit.\nSi on souhaite désinstaller une extension précédemment installée, on peut utiliser la fonction remove.packages() :\n\nremove.packages(\"gtsummary\")\n\n\n\n\n\n\n\nInstaller / Mettre à jour les packages utilisés par un projet\n\n\n\nAprès une mise à jour majeure de R, il est souvent nécessaire de réinstaller tous les packages utilisés. De même, on peut parfois souhaiter mettre à jour uniquement les packages utilisés par un projet donné sans avoir à mettre à jour tous les autres packages présents sur son PC.\nUne astuce consiste à avoir recours à la fonction renv::dependencies() qui examine le code du projet courant pour identifier les packages utilisés, puis à passer cette liste de packages à remotes::install_cran() qui installera les packages manquants ou pour lesquels une mise à jour est disponible.\nIl vous suffit d’exécuter la commande ci-dessous :\n\nrenv::dependencies() |> \n  purrr::pluck(\"Package\") |> \n  remotes::install_cran()"
  },
  {
    "objectID": "bases/packages.html#installation-depuis-github",
    "href": "bases/packages.html#installation-depuis-github",
    "title": "1  Packages",
    "section": "\n1.4 Installation depuis GitHub",
    "text": "1.4 Installation depuis GitHub\nCertains packages ne sont pas disponibles sur CRAN mais seulement sur GitHub, une plateforme de développement informatique. Il s’agit le plus souvent de packages qui ne sont pas encore suffisament matures pour être diffusés sur CRAN (sachant que des vérifications strictes sont effectués avant qu’un package ne soit référencés sur CRAN).\nDans d’autres cas de figure, la dernière version stable d’un package est disponible sur CRAN tandis que la version en cours de développement est, elle, disponible sur GitHub. Il fuat être vigilant avec les versions de développement. Parfois, elle corrige un bug ou introduit une nouvelle fonctionnalité qui n’est pas encore dans la version stable. Mais les versions de développement peuvent aussi contenir de nouveaux bugs ou des fonctionnalités instables.\n\n\n\n\n\n\nSous Windows\n\n\n\nPour les utilisatrices et utilisateurs sous Windows, il faut être conscient que le code source d’un package doit être compilé afin de pouvoir être utilisé. CRAN fournit une version des packages déjà compilée pour Windows ce qui facilite l’installation.\nPar contre, lorsque l’on installe un package depuis GitHub, R ne récupère que le code source et il est donc nécessaire de compiler localement le package. Pour cela, il est nécessaire que soit installé sur le PC un outil complémentaire appelé RTools. Il est téléchargeable à l’adresse https://cran.r-project.org/bin/windows/Rtools/.\n\n\nLe code source du package labelled est disponible sur GitHub à l’adresse https://github.com/larmarange/labelled. Pour installer la version de développement de labelled,on aura recours à la fonction remotes::install_github() à laquelle on passera la partie située à droite de https://github.com/ dans l’URL du package, à savoir :\n\nremotes::install_github(\"larmarange/labelled\")"
  },
  {
    "objectID": "bases/packages.html#le-tidyverse",
    "href": "bases/packages.html#le-tidyverse",
    "title": "1  Packages",
    "section": "\n1.5 Le tidyverse",
    "text": "1.5 Le tidyverse\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par bien rangé) et de universe. Il s’agit en fait d’une collection de packages conçus pour travailler ensemble et basés sur une philosophie commune.\nIls abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) :\n\nvisualisation (ggplot2)\nmanipulation des tableaux de données (dplyr, tidyr)\nimport/export de données (readr, readxl, haven)\nmanipulation de variables (forcats, stringr, lubridate)\nprogrammation (purrr, magrittr, glue)\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio.\ntidyverse est également le nom d’une extension générique qui permets d’installer en une seule commande l’ensemble des packages constituant le tidyverse :\n\ninstall.packages(\"tidyverse\")\n\nLorsque l’on charge le package tidyverse avec library(), cela charge également en mémoire les principaux packages du tidyverse1.1 Si on a besoin d’un autre package du tidyverse comme lubridate, il faudra donc le charger individuellement.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\n\nFigure 1.1: Packages chargés avec library(tidyverse)"
  },
  {
    "objectID": "bases/vecteurs.html",
    "href": "bases/vecteurs.html",
    "title": "2  Vecteurs",
    "section": "",
    "text": "Les vecteurs sont l’objet de base de R et correspondent à une liste de valeurs. Leurs propriétés fondamentales sont :"
  },
  {
    "objectID": "bases/vecteurs.html#types-et-classes",
    "href": "bases/vecteurs.html#types-et-classes",
    "title": "2  Vecteurs",
    "section": "\n2.1 Types et classes",
    "text": "2.1 Types et classes\nDans R, il existe plusieurs types fondamentaux de vecteurs et, en particulier, :\n\nles nombres réels (c’est-à-dire les nombres décimaux1), par exemple 5.23 ;\nles nombres entiers, que l’on saisi en ajoutant le suffixe L2, par exemple 4L ;\nles chaînes de caractères (qui correspondent à du texte), que l’on saisit avec des guillemets doubles (\") ou simples ('), par exemple \"abc\" ;\nles valeurs logiques ou valeurs booléennes, à savoir vrai ou faux, que l’on représente avec les mots TRUE et FALSE (en majuscules3).\n\n1 Pour rappel, R étant anglophone, le caractère utilisé pour indiqué les chiffres après la virgule est le point (.).2 R utilise 32 bits pour représenter des nombres entiers, ce qui correspond en informatique à des entiers longs ou long integers en anglais, d’où la lettre L utilisée pour indiquer un nombre entier.3 On peut également utiliser les raccourcis T et F. Cependant, pour une meilleure lisibilité du code, il est préférable d’utiliser les versions longues TRUE et FALSE.En plus de ces types de base, il existe de nombreux autres types de vecteurs utilisés pour représenter toutes sortes de données, comme les facteurs (voir Chapitre 8) ou les dates (voir Chapitre 9).\nLa fonction class() renvoie la nature d’un vecteur tandis que la fonction typeof() indique la manière dont un vecteur est stocké de manière interne par R.\n\n\n\n\n\n\n\n\n\nx\nclass(x)\ntypeof(x)\n\n\n\n3L\ninteger\ninteger\n\n\n5.3\nnumeric\ndouble\n\n\nTRUE\nlogical\nlogical\n\n\n\"abc\"\ncharacter\ncharacter\n\n\nfactor(\"a\")\nfactor\ninteger\n\n\nas.Date(\"2020-01-01\")\nDate\ndouble\n\n\n\nTable 2.1: Le type et la classe des principaux types de vecteurs\n\n\n\n\n\n\nAstuce\n\n\n\nPour un vecteur numérique, le type est \"double\" car R utilise une double précision pour stocker informatiquement les nombres réels.\nEn interne, les facteurs sont représentés par un nombre entier auquel est attaché une étiquette, c’est pourquoi typeof() renvoie \"integer\".\nQuand aux dates, elles sont stockées en interne sous la forme d’un nombre réel représentant le nombre de jours depuis le 1er janvier 1970, d’où le fait que typeof() renvoie \"double\"."
  },
  {
    "objectID": "bases/vecteurs.html#création-dun-vecteur",
    "href": "bases/vecteurs.html#création-dun-vecteur",
    "title": "2  Vecteurs",
    "section": "\n2.2 Création d’un vecteur",
    "text": "2.2 Création d’un vecteur\nPour créer un vecteur, on utilisera la fonction c() en lui passant la liste des valeurs à combiner4.4 La lettre c est un raccourci du mot anglais combine, puisque cette fonction permet de combiner des valeurs individuelles dans un vecteur unique.\n\ntaille <- c(1.88, 1.65, 1.92, 1.76, NA, 1.72)\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\nsexe <- c(\"h\", \"f\", \"h\", \"f\", \"f\", \"f\")\nsexe\n\n[1] \"h\" \"f\" \"h\" \"f\" \"f\" \"f\"\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\nurbain\n\n[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\n\n\nNous l’avons vu, toutes les valeurs d’un vecteur doivent obligatoirement être du même type. Dès lors, si on essaie de combiner des valeurs de différents types, R essaiera de les convertir au mieux. Par exemple :\n\nx <- c(2L, 3.14, \"a\")\nx\n\n[1] \"2\"    \"3.14\" \"a\"   \n\nclass(x)\n\n[1] \"character\"\n\n\nDans le cas présent, toutes les valeurs ont été converties en chaînes de caractères.\nDans certaines situations, on peut avoir besoin de créer un vecteur d’une certaine longueur mais dont toutes les valeurs sont identiques. Cela se réalise facilement avec rep() à qui on indiquera la valeur à répéter puis le nombre de répétitions :\n\nrep(2, 10)\n\n [1] 2 2 2 2 2 2 2 2 2 2\n\n\nOn peut aussi lui indiquer plusieurs valeurs qui seront alors répétées en boucle :\n\nrep(c(\"a\", \"b\"), 3)\n\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n\n\nDans d’autres situations, on peut avoir besoin de créer un vecteur contenant une suite de valeurs, ce qui se réalise aisément avec seq() à qui on précisera les arguments from (point de départ), to (point d’arrivée) et by (pas). Quelques exemples valent mieux qu’un long discours :\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(5, 17, by = 2)\n\n[1]  5  7  9 11 13 15 17\n\nseq(10, 0)\n\n [1] 10  9  8  7  6  5  4  3  2  1  0\n\nseq(100, 10, by = -10)\n\n [1] 100  90  80  70  60  50  40  30  20  10\n\nseq(1.23, 5.67, by = 0.33) \n\n [1] 1.23 1.56 1.89 2.22 2.55 2.88 3.21 3.54 3.87 4.20 4.53 4.86 5.19 5.52\n\n\nL’opérateur : est un raccourci de la fonction seq() pour créer une suite de nombres entiers. Il s’utilise ainsi :\n\n1:5\n\n[1] 1 2 3 4 5\n\n24:32\n\n[1] 24 25 26 27 28 29 30 31 32\n\n55:43\n\n [1] 55 54 53 52 51 50 49 48 47 46 45 44 43"
  },
  {
    "objectID": "bases/vecteurs.html#longueur-dun-vecteur",
    "href": "bases/vecteurs.html#longueur-dun-vecteur",
    "title": "2  Vecteurs",
    "section": "\n2.3 Longueur d’un vecteur",
    "text": "2.3 Longueur d’un vecteur\nLa longueur d’un vecteur correspond au nombre de valeurs qui le composent. Elle s’obtient avec length() :\n\nlength(taille)\n\n[1] 6\n\nlength(c(\"a\", \"b\"))\n\n[1] 2\n\n\nLa longueur d’un vecteur vide (NULL) est zéro.\n\nlength(NULL)\n\n[1] 0"
  },
  {
    "objectID": "bases/vecteurs.html#combiner-des-vecteurs",
    "href": "bases/vecteurs.html#combiner-des-vecteurs",
    "title": "2  Vecteurs",
    "section": "\n2.4 Combiner des vecteurs",
    "text": "2.4 Combiner des vecteurs\nPour combiner des vecteurs, rien de plus simple. Il suffit d’utiliser c() ! Les valeurs des différents vecteurs seront mises bout à bout pour créer un unique vecteur.\n\nx <- c(2, 1, 3, 4)\nlength(x)\n\n[1] 4\n\ny <- c(9, 1, 2, 6, 3, 0)\nlength(y)\n\n[1] 6\n\nz <- c(x, y)\nz\n\n [1] 2 1 3 4 9 1 2 6 3 0\n\nlength(z)\n\n[1] 10"
  },
  {
    "objectID": "bases/vecteurs.html#vecteurs-nommés",
    "href": "bases/vecteurs.html#vecteurs-nommés",
    "title": "2  Vecteurs",
    "section": "\n2.5 Vecteurs nommés",
    "text": "2.5 Vecteurs nommés\nLes différentes valeurs d’un vecteur peuvent être nommées. Une première manière de nommer les éléments d’un vecteur est de le faire à sa création :\n\nsexe <- c(\n  Michel = \"h\", Anne = \"f\", \n  Dominique = NA, Jean = \"h\", \n  Claude = NA, Marie = \"f\"\n)\n\nLorsqu’on affiche le vecteur, la présentation change quelque peu.\n\nsexe\n\n   Michel      Anne Dominique      Jean    Claude     Marie \n      \"h\"       \"f\"        NA       \"h\"        NA       \"f\" \n\n\nLa liste des noms s’obtient avec names().\n\nnames(sexe)\n\n[1] \"Michel\"    \"Anne\"      \"Dominique\" \"Jean\"      \"Claude\"    \"Marie\"    \n\n\nPour ajouter ou modifier les noms d’un vecteur, on doit attribuer un nouveau vecteur de noms :\n\nnames(sexe) <- c(\"Michael\", \"Anna\", \"Dom\", \"John\", \"Alex\", \"Mary\")\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\n\nPour supprimer tous les noms, il y a la fonction unname() :\n\nanonyme <- unname(sexe)\nanonyme\n\n[1] \"h\" \"f\" NA  \"h\" NA  \"f\""
  },
  {
    "objectID": "bases/vecteurs.html#indexation-par-position",
    "href": "bases/vecteurs.html#indexation-par-position",
    "title": "2  Vecteurs",
    "section": "\n2.6 Indexation par position",
    "text": "2.6 Indexation par position\nL’indexation est l’une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de R. Il s’agit d’opérations permettant de sélectionner des sous-ensembles de valeurs en fonction de différents critères. Il existe trois types d’indexation : (i) l’indexation par position, (ii) l’indexation par nom et (iii) l’indexation par condition. Le principe est toujours le même : on indique entre crochets5 ([]) ce qu’on souhaite garder ou non.5 Pour rappel, les crochets s’obtiennent sur un clavier français de type PC en appuyant sur la touche Alt Gr et la touche ( ou ).\nCommençons par l’indexation par position encore appelée indexation directe. Ce mode le plus simple d’indexation consiste à indiquer la position des éléments à conserver.\nReprenons notre vecteur taille :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\n\nSi on souhaite le premier élément du vecteur, on peut faire :\n\ntaille[1]\n\n[1] 1.88\n\n\nSi on souhaite les trois premiers éléments ou les éléments 2, 5 et 6 :\n\ntaille[1:3]\n\n[1] 1.88 1.65 1.92\n\ntaille[c(2, 5, 6)]\n\n[1] 1.65   NA 1.72\n\n\nSi on veut le dernier élément :\n\ntaille[length(taille)]\n\n[1] 1.72\n\n\nIl est tout à fait possible de sélectionner les valeurs dans le désordre :\n\ntaille[c(5, 1, 4, 3)]\n\n[1]   NA 1.88 1.76 1.92\n\n\nDans le cadre de l’indexation par position, il est également possible de spécifier des nombres négatifs, auquel cas cela signifiera toutes les valeurs sauf celles-là. Par exemple :\n\ntaille[c(-1, -5)]\n\n[1] 1.65 1.92 1.76 1.72\n\n\nÀ noter, si on indique une position au-delà de la longueur du vecteur, R renverra NA. Par exemple :\n\ntaille[23:25]\n\n[1] NA NA NA"
  },
  {
    "objectID": "bases/vecteurs.html#indexation-par-nom",
    "href": "bases/vecteurs.html#indexation-par-nom",
    "title": "2  Vecteurs",
    "section": "\n2.7 Indexation par nom",
    "text": "2.7 Indexation par nom\nLorsqu’un vecteur est nommé, il est dès lors possible d’accéder à ses valeurs à partir de leur nom. Il s’agit de l’indexation par nom.\n\nsexe[\"Anna\"]\n\nAnna \n \"f\" \n\nsexe[c(\"Mary\", \"Michael\", \"John\")]\n\n   Mary Michael    John \n    \"f\"     \"h\"     \"h\" \n\n\nPar contre il n’est pas possible d’utiliser l’opérateur - comme pour l’indexation directe. Pour exclure un élément en fonction de son nom, on doit utiliser une autre forme d’indexation, l’indexation par condition, expliquée dans la section suivante. On peut ainsi faire…\n\nsexe[names(sexe) != \"Dom\"]\n\n… pour sélectionner tous les éléments sauf celui qui s’appelle Dom."
  },
  {
    "objectID": "bases/vecteurs.html#indexation-par-condition",
    "href": "bases/vecteurs.html#indexation-par-condition",
    "title": "2  Vecteurs",
    "section": "\n2.8 Indexation par condition",
    "text": "2.8 Indexation par condition\nL’indexation par condition consiste à fournir un vecteur logique indiquant si chaque élément doit être inclus (si TRUE) ou exclu (si FALSE). Par exemple :\n\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\nsexe[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n\nMichael    John \n    \"h\"     \"h\" \n\n\nÉcrire manuellement une telle condition n’est pas très pratique à l’usage. Mais supposons que nous ayons également à notre disposition les deux vecteurs suivants, également de longueur 6.\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\npoids <- c(80, 63, 75, 87, 82, 67)\n\nLe vecteur urbain est un vecteur logique. On peut directement l’utiliser pour avoir le sexe des enquêtés habitant en milieu urbain :\n\nsexe[urbain]\n\nMichael    Anna    Mary \n    \"h\"     \"f\"     \"f\" \n\n\nSupposons qu’on souhaite maintenant avoir la taille des individus pesant 80 kilogrammes ou plus. Nous pouvons effectuer une comparaison à l’aide des opérateurs de comparaison suivants :\n\n\n\n\nOpérateur de comparaison\nSignification\n\n\n\n==\négal à\n\n\n%in%\nappartient à\n\n\n!=\ndifférent de\n\n\n>\nstrictement supérieur à\n\n\n<\nstrictement inférieur à\n\n\n>=\nsupérieur ou égal à\n\n\n<=\ninférieur ou égal à\n\n\n\nTable 2.2: Opérateurs de comparaison\nVoyons tout de suite un exemple :\n\npoids >= 80\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n\nQue s’est-il passé ? Nous avons fourni à R une condition et il nous a renvoyé un vecteur logique avec autant d’éléments qu’il y a d’observations et dont la valeur est TRUE si la condition est remplie et FALSE dans les autres cas. Nous pouvons alors utiliser ce vecteur logique pour obtenir la taille des participants pesant 80 kilogrammes ou plus :\n\ntaille[poids >= 80]\n\n[1] 1.88 1.76   NA\n\n\nOn peut combiner ou modifier des conditions à l’aide des opérateurs logiques habituels :\n\n\n\n\nOpérateur logique\nSignification\n\n\n\n&\net logique\n\n\n|\nou logique\n\n\n!\nnégation logique\n\n\n\nTable 2.3: Opérateurs logiques\nSupposons que je veuille identifier les personnes pesant 80 kilogrammes ou plus et vivant en milieu urbain :\n\npoids >= 80 & urbain\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nLes résultats sont différents si je souhaite isoler les personnes pesant 80 kilogrammes ou plus ou vivant milieu urbain :\n\npoids >= 80 | urbain\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\n\n\n\n\n\n\nComparaison et valeur manquante\n\n\n\nUne remarque importante : quand l’un des termes d’une condition comporte une valeur manquante (NA), le résultat de cette condition n’est pas toujours TRUE ou FALSE, il peut aussi être à son tour une valeur manquante.\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\ntaille > 1.8\n\n[1]  TRUE FALSE  TRUE FALSE    NA FALSE\n\n\nOn voit que le test NA > 1.8 ne renvoie ni vrai ni faux, mais NA.\nUne autre conséquence importante de ce comportement est qu’on ne peut pas utiliser l’opérateur l’expression == NA pour tester la présence de valeurs manquantes. On utilisera à la place la fonction ad hoc is.na() :\n\nis.na(taille > 1.8)\n\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE\n\n\nPour compliquer encore un peu le tout, lorsqu’on utilise une condition pour l’indexation, si la condition renvoie NA, R ne sélectionne pas l’élément mais retourne quand même la valeur NA. Ceci a donc des conséquences sur le résultat d’une indexation par comparaison.\nPar exemple si je cherche à connaître le poids des personnes mesurant 1,80 mètre ou plus :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\npoids\n\n[1] 80 63 75 87 82 67\n\npoids[taille > 1.8]\n\n[1] 80 75 NA\n\n\nLes éléments pour lesquels la taille n’est pas connue ont été transformés en NA, ce qui n’influera pas le calcul d’une moyenne. Par contre, lorsqu’on utilisera assignation et indexation ensemble, cela peut créer des problèmes. Il est donc préférable lorsqu’on a des valeurs manquantes de les exclure ainsi :\n\npoids[taille > 1.8 & !is.na(taille)]\n\n[1] 80 75"
  },
  {
    "objectID": "bases/vecteurs.html#assignation-par-indexation",
    "href": "bases/vecteurs.html#assignation-par-indexation",
    "title": "2  Vecteurs",
    "section": "\n2.9 Assignation par indexation",
    "text": "2.9 Assignation par indexation\nL’indexation peut être combinée avec l’assignation (opérateur <-) pour modifier seulement certaines parties d’un vecteur. Ceci fonctionne pour les différents types d’indexation évoqués précédemment.\n\nv <- 1:5\nv\n\n[1] 1 2 3 4 5\n\nv[1] <- 3\nv\n\n[1] 3 2 3 4 5\n\nsexe[\"Alex\"] <- \"non-binaire\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n          \"h\"           \"f\"            NA           \"h\" \"non-binaire\" \n         Mary \n          \"f\" \n\n\nEnfin on peut modifier plusieurs éléments d’un seul coup soit en fournissant un vecteur, soit en profitant du mécanisme de recyclage. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :\n\nsexe[c(1,3,4)] <- c(\"Homme\", \"Homme\", \"Homme\")\nsexe[c(1,3,4)] <- \"Homme\"\n\nL’assignation par indexation peut aussi être utilisée pour ajouter une ou plusieurs valeurs à un vecteur :\n\nlength(sexe)\n\n[1] 6\n\nsexe[7] <- \"f\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n      \"Homme\"           \"f\"       \"Homme\"       \"Homme\" \"non-binaire\" \n         Mary               \n          \"f\"           \"f\" \n\nlength(sexe)\n\n[1] 7"
  },
  {
    "objectID": "bases/vecteurs.html#en-résumé",
    "href": "bases/vecteurs.html#en-résumé",
    "title": "2  Vecteurs",
    "section": "\n2.10 En résumé",
    "text": "2.10 En résumé\n\nUn vecteur est un objet unidimensionnel contenant une liste de valeurs qui sont toutes du même type (entières, numériques, textuelles ou logiques).\nLa fonction class() permet de connaître le type du vecteur et la fonction length() sa longueur, c’est-à-dire son nombre d’éléments.\nLa fonction c() sert à créer et à combiner des vecteurs.\nLes valeurs manquantes sont représentées avec NA.\nUn vecteur peut être nommé, c’est-à-dire qu’un nom textuel a été associé à chaque élément. Cela peut se faire lors de sa création ou avec la fonction names().\nL’indexation consiste à extraire certains éléments d’un vecteur. Pour cela, on indique ce qu’on souhaite extraire entre crochets ([]) juste après le nom du vecteur. Le type d’indexation dépend du type d’information transmise.\nS’il s’agit de nombres entiers, c’est l’indexation par position : les nombres représentent la position dans le vecteur des éléments qu’on souhaite extraire. Un nombre négatif s’interprète comme tous les éléments sauf celui-là.\nSi on indique des chaînes de caractères, c’est l’indexation par nom : on indique le nom des éléments qu’on souhaite extraire. Cette forme d’indexation ne fonctionne que si le vecteur est nommé.\nSi on transmet des valeurs logiques, le plus souvent sous la forme d’une condition, c’est l’indexation par condition : TRUE indique les éléments à extraire et FALSE les éléments à exclure. Il faut être vigilant aux valeurs manquantes (NA) dans ce cas précis.\nEnfin, il est possible de ne modifier que certains éléments d’un vecteur en ayant recours à la fois à l’indexation ([]) et à l’assignation (<-)."
  },
  {
    "objectID": "bases/vecteurs.html#webin-r",
    "href": "bases/vecteurs.html#webin-r",
    "title": "2  Vecteurs",
    "section": "\n2.11 webin-R",
    "text": "2.11 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "bases/listes.html",
    "href": "bases/listes.html",
    "title": "3  Listes",
    "section": "",
    "text": "Par nature, les vecteurs ne peuvent contenir que des valeurs de même type (numérique, textuel ou logique). Or, on peut avoir besoin de représenter des objets plus complexes composés d’éléments disparates. C’est ce que permettent les listes."
  },
  {
    "objectID": "bases/listes.html#propriétés-et-création",
    "href": "bases/listes.html#propriétés-et-création",
    "title": "3  Listes",
    "section": "\n3.1 Propriétés et création",
    "text": "3.1 Propriétés et création\nUne liste se crée tout simplement avec la fonction list() :\n\nl1 <- list(1:5, \"abc\")\nl1\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n\nUne liste est un ensemble d’objets, quels qu’ils soient, chaque élément d’une liste pouvant avoir ses propres dimensions. Dans notre exemple précédent, nous avons créé une liste l1 composée de deux éléments : un vecteur d’entiers de longueur 5 et un vecteur textuel de longueur 1. La longueur d’une liste correspond aux nombres d’éléments qu’elle contient et s’obtient avec length() :\n\nlength(l1)\n\n[1] 2\n\n\nComme les vecteurs, une liste peut être nommée et les noms des éléments d’une liste sont accessibles avec names() :\n\nl2 <- list(\n  minuscules = letters, \n  majuscules = LETTERS, \n  mois = month.name\n)\nl2\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nlength(l2)\n\n[1] 3\n\nnames(l2)\n\n[1] \"minuscules\" \"majuscules\" \"mois\"      \n\n\nQue se passe-t-il maintenant si on effectue la commande suivante ?\n\nl <- list(l1, l2)\n\nÀ votre avis, quelle est la longueur de cette nouvelle liste l ? 5 ?\n\nlength(l)\n\n[1] 2\n\n\nEh bien non ! Elle est de longueur 2 car nous avons créé une liste composée de deux éléments qui sont eux-mêmes des listes. Cela est plus lisible si on fait appel à la fonction str() qui permet de visualiser la structure d’un objet.\n\nstr(l)\n\nList of 2\n $ :List of 2\n  ..$ : int [1:5] 1 2 3 4 5\n  ..$ : chr \"abc\"\n $ :List of 3\n  ..$ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n  ..$ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\nUne liste peut contenir tous types d’objets, y compris d’autres listes. Pour combiner les éléments d’une liste, il faut utiliser la fonction append() :\n\nl <- append(l1, l2)\nlength(l)\n\n[1] 5\n\nstr(l)\n\nList of 5\n $           : int [1:5] 1 2 3 4 5\n $           : chr \"abc\"\n $ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n $ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\n\n\n\n\n\n\nNote\n\n\n\nOn peut noter en passant qu’une liste peut tout à fait n’être que partiellement nommée."
  },
  {
    "objectID": "bases/listes.html#indexation",
    "href": "bases/listes.html#indexation",
    "title": "3  Listes",
    "section": "\n3.2 Indexation",
    "text": "3.2 Indexation\nLes crochets simples ([]) fonctionnent comme pour les vecteurs. On peut utiliser à la fois l’indexation par position, l’indexation par nom et l’indexation par condition.\n\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nl[c(1,3,4)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nl[c(\"majuscules\", \"minuscules\")]\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nl[c(TRUE, TRUE, FALSE, FALSE, TRUE)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMême si on extrait un seul élément, l’extraction obtenue avec les crochets simples renvoie toujours une liste, ici composée d’un seul élément :\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\n\nSupposons que je souhaite calculer la moyenne des valeurs du premier élément de ma liste. Essayons la commande suivante :\n\nmean(l[1])\n\nWarning in mean.default(l[1]): l'argument n'est ni numérique, ni logique :\nrenvoi de NA\n\n\n[1] NA\n\n\nNous obtenons un message d’erreur. En effet, R ne sait pas calculer une moyenne à partir d’une liste. Ce qu’il lui faut, c’est un vecteur de valeurs numériques. Autrement dit, ce que nous cherchons à obtenir c’est le contenu même du premier élément de notre liste et non une liste à un seul élément.\nC’est ici que les doubles crochets ([[]]) vont rentrer en jeu. Pour ces derniers, nous pourrons utiliser l’indexation par position ou l’indexation par nom, mais pas l’indexation par condition. De plus, le critère qu’on indiquera doit indiquer un et un seul élément de notre liste. Au lieu de renvoyer une liste à un élément, les doubles crochets vont renvoyer l’élément désigné.\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\nstr(l[[1]])\n\n int [1:5] 1 2 3 4 5\n\n\nMaintenant, nous pouvons calculer notre moyenne :\n\nmean(l[[1]])\n\n[1] 3\n\n\nNous pouvons aussi utiliser l’indexation par nom.\n\nl[[\"mois\"]]\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMais il faut avouer que cette écriture avec doubles crochets et guillemets est un peu lourde. Heureusement, un nouvel acteur entre en scène : le symbole dollar ($). C’est un raccourci des doubles crochets pour l’indexation par nom qu’on utilise ainsi :\n\nl$mois\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nLes écritures l$mois et l[[\"mois\"]] sont équivalentes. Attention ! Cela ne fonctionne que pour l’indexation par nom.\n\nl$1\n\n\nError: unexpected numeric constant in \"l$1\"\n\nL’assignation par indexation fonctionne également avec les doubles crochets ou le signe dollar :\n\nl[[2]] <- list(c(\"un\", \"vecteur\", \"textuel\"))\nl$mois <- c(\"Janvier\", \"Février\", \"Mars\")\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[[2]][[1]]\n[1] \"un\"      \"vecteur\" \"textuel\"\n\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n[1] \"Janvier\" \"Février\" \"Mars\""
  },
  {
    "objectID": "bases/listes.html#en-résumé",
    "href": "bases/listes.html#en-résumé",
    "title": "3  Listes",
    "section": "\n3.3 En résumé",
    "text": "3.3 En résumé\n\nLes listes sont des objets unidimensionnels pouvant contenir tout type d’objet, y compris d’autres listes.\nElles ont une longueur qu’on obtient avec length().\nOn crée une liste avec list() et on peut fusionner des listes avec append().\nTout comme les vecteurs, les listes peuvent être nommées et les noms des éléments s’obtiennent avec base::names().\nLes crochets simples ([]) permettent de sélectionner les éléments d’une liste, en utilisant l’indexation par position, l’indexation par nom ou l’indexation par condition. Cela renvoie toujours une autre liste.\nLes doubles crochets ([[]]) renvoient directement le contenu d’un élément de la liste qu’on aura sélectionné par position ou par nom.\nLe symbole $ est un raccourci pour facilement sélectionner un élément par son nom, liste$nom étant équivalent à liste[[\"nom\"]]."
  },
  {
    "objectID": "bases/listes.html#webin-r",
    "href": "bases/listes.html#webin-r",
    "title": "3  Listes",
    "section": "\n3.4 webin-R",
    "text": "3.4 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "bases/tableaux_donnees.html",
    "href": "bases/tableaux_donnees.html",
    "title": "4  Tableaux de données",
    "section": "",
    "text": "Les tableaux de données, ou data frame en anglais, est un type d’objets essentiel pour les données d’enquêtes."
  },
  {
    "objectID": "bases/tableaux_donnees.html#propriétés-et-création",
    "href": "bases/tableaux_donnees.html#propriétés-et-création",
    "title": "4  Tableaux de données",
    "section": "\n4.1 Propriétés et création",
    "text": "4.1 Propriétés et création\nDans R, les tableaux de données sont tout simplement des listes (voir Chapitre 3) avec quelques propriétés spécifiques :\n\nles tableaux de données ne peuvent contenir que des vecteurs ;\ntous les vecteurs d’un tableau de données ont la même longueur ;\ntous les éléments d’un tableau de données sont nommés et ont chacun un nom unique.\n\nDès lors, un tableau de données correspond aux fichiers de données qu’on a l’habitude de manipuler dans d’autres logiciels de statistiques comme SPSS ou Stata. Les variables sont organisées en colonnes et les observations en lignes.\nOn peut créer un tableau de données avec la fonction data.frame() :\n\ndf <- data.frame(\n  sexe =  c(\"f\", \"f\", \"h\", \"h\"), \n  age = c(52, 31, 29, 35), \n  blond = c(FALSE, TRUE, TRUE, FALSE)\n)\ndf\n\n  sexe age blond\n1    f  52 FALSE\n2    f  31  TRUE\n3    h  29  TRUE\n4    h  35 FALSE\n\nstr(df)\n\n'data.frame':   4 obs. of  3 variables:\n $ sexe : chr  \"f\" \"f\" \"h\" \"h\"\n $ age  : num  52 31 29 35\n $ blond: logi  FALSE TRUE TRUE FALSE\n\n\nUn tableau de données étant une liste, la fonction length() renverra le nombre d’éléments de la liste, donc dans le cas présent le nombre de variables, et names() leurs noms :\n\nlength(df)\n\n[1] 3\n\nnames(df)\n\n[1] \"sexe\"  \"age\"   \"blond\"\n\n\nComme tous les éléments d’un tableau de données ont la même longueur, cet objet peut être vu comme bidimensionnel. Les fonctions nrow(), ncol() et dim() donnent respectivement le nombre de lignes, le nombre de colonnes et les dimensions de notre tableau.\n\nnrow(df)\n\n[1] 4\n\nncol(df)\n\n[1] 3\n\ndim(df)\n\n[1] 4 3\n\n\nDe plus, tout comme les colonnes ont un nom, il est aussi possible de nommer les lignes avec row.names() :\n\nrow.names(df) <- c(\"Anna\", \"Mary-Ann\", \"Michael\", \"John\")\ndf\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\nMichael     h  29  TRUE\nJohn        h  35 FALSE"
  },
  {
    "objectID": "bases/tableaux_donnees.html#indexation",
    "href": "bases/tableaux_donnees.html#indexation",
    "title": "4  Tableaux de données",
    "section": "\n4.2 Indexation",
    "text": "4.2 Indexation\nLes tableaux de données étant des listes, nous pouvons donc utiliser les crochets simples ([]), les crochets doubles ([[]]) et le symbole dollar ($) pour extraire des parties de notre tableau, de la même manière que pour n’importe quelle liste.\n\ndf[1]\n\n         sexe\nAnna        f\nMary-Ann    f\nMichael     h\nJohn        h\n\ndf[[1]]\n\n[1] \"f\" \"f\" \"h\" \"h\"\n\ndf$sexe\n\n[1] \"f\" \"f\" \"h\" \"h\"\n\n\nCependant, un tableau de données étant un objet bidimensionnel, il est également possible d’extraire des données sur deux dimensions, à savoir un premier critère portant sur les lignes et un second portant sur les colonnes. Pour cela, nous utiliserons les crochets simples ([]) en séparant nos deux critères par une virgule (,).\nUn premier exemple :\n\ndf\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\nMichael     h  29  TRUE\nJohn        h  35 FALSE\n\ndf[3, 2]\n\n[1] 29\n\n\nCette première commande indique que nous souhaitons la troisième ligne de la seconde colonne, autrement dit l’âge de Michael. Le même résultat peut être obtenu avec l’indexation par nom, l’indexation par condition, ou un mélange de tout ça.\n\ndf[\"Michael\", \"age\"]\n\n[1] 29\n\ndf[c(F, F, T, F), c(F, T, F)]\n\n[1] 29\n\ndf[3, \"age\"]\n\n[1] 29\n\ndf[\"Michael\", 2]\n\n[1] 29\n\n\nIl est également possible de préciser un seul critère. Par exemple, si je souhaite les deux premières observations, ou les variables sexe et blond :\n\ndf[1:2,]\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\n\ndf[,c(\"sexe\", \"blond\")]\n\n         sexe blond\nAnna        f FALSE\nMary-Ann    f  TRUE\nMichael     h  TRUE\nJohn        h FALSE\n\n\nIl a suffi de laisser un espace vide avant ou après la virgule.\n\n\n\n\n\n\nAvertissement\n\n\n\nATTENTION ! Il est cependant impératif de laisser la virgule pour indiquer à R qu’on souhaite effectuer une indexation à deux dimensions. Si on oublie la virgule, cela nous ramène au mode de fonctionnement des listes. Et le résultat n’est pas forcément le même :\n\ndf[2, ]\n\n         sexe age blond\nMary-Ann    f  31  TRUE\n\ndf[, 2]\n\n[1] 52 31 29 35\n\ndf[2]\n\n         age\nAnna      52\nMary-Ann  31\nMichael   29\nJohn      35\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAu passage, on pourra noter quelques subtilités sur le résultat renvoyé.\n\nstr(df[2, ])\n\n'data.frame':   1 obs. of  3 variables:\n $ sexe : chr \"f\"\n $ age  : num 31\n $ blond: logi TRUE\n\nstr(df[, 2])\n\n num [1:4] 52 31 29 35\n\nstr(df[2])\n\n'data.frame':   4 obs. of  1 variable:\n $ age: num  52 31 29 35\n\nstr(df[[2]])\n\n num [1:4] 52 31 29 35\n\n\ndf[2, ] signifie qu’on veut toutes les variables pour le second individu. Le résultat est un tableau de données à une ligne et trois colonnes. df[2] correspond au mode d’extraction des listes et renvoie donc une liste à un élément, en l’occurrence un tableau de données à quatre observations et une variable. df[[2]] quant à lui renvoie le contenu de cette variable, soit un vecteur numérique de longueur quatre. Reste df[, 2] qui renvoie toutes les observations pour la seconde colonne. Or l’indexation bidimensionnelle a un fonctionnement un peu particulier : par défaut elle renvoie un tableau de données mais s’il y a une seule variable dans l’extraction, c’est un vecteur qui est renvoyé. Pour plus de détails, on pourra consulter l’entrée d’aide help(\"[.data.frame\")."
  },
  {
    "objectID": "bases/tableaux_donnees.html#afficher-les-données",
    "href": "bases/tableaux_donnees.html#afficher-les-données",
    "title": "4  Tableaux de données",
    "section": "\n4.3 Afficher les données",
    "text": "4.3 Afficher les données\nPrenons un tableau de données un peu plus conséquent, en l’occurrence le jeu de données ?questionr::hdv2003 disponible dans l’extension questionr et correspondant à un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables.\n\nlibrary(questionr)\ndata(hdv2003)\n\nSi on demande d’afficher l’objet hdv2003 dans la console (résultat non reproduit ici), R va afficher l’ensemble du contenu de hdv2003 à l’écran ce qui, sur un tableau de cette taille, ne sera pas très lisible. Pour une exploration visuelle, le plus simple est souvent d’utiliser la visionneuse intégrée à RStudio et qu’on peut appeler avec la fonction View().\n\nView(hdv2003)\n\n\n\nFigure 4.1: Interface View() de R RStudio\n\n\nLes fonctions head() et tail(), qui marchent également sur les vecteurs, permettent d’afficher seulement les premières (respectivement les dernières) lignes d’un tableau de données :\n\nhead(hdv2003)\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n2  2  23 Femme                                                 <NA> 9738.396\n3  3  59 Homme                    Derniere annee d'etudes primaires 3994.102\n4  4  34 Homme Enseignement superieur y compris technique superieur 5731.662\n5  5  71 Femme                    Derniere annee d'etudes primaires 4329.094\n6  6  35 Femme        Enseignement technique ou professionnel court 8674.699\n                  occup     qualif freres.soeurs clso\n1 Exerce une profession    Employe             8  Oui\n2       Etudiant, eleve       <NA>             2  Oui\n3 Exerce une profession Technicien             2  Non\n4 Exerce une profession Technicien             1  Non\n5              Retraite    Employe             0  Oui\n6 Exerce une profession    Employe             5  Non\n                        relig                     trav.imp    trav.satisf\n1 Ni croyance ni appartenance                Peu important Insatisfaction\n2 Ni croyance ni appartenance                         <NA>           <NA>\n3 Ni croyance ni appartenance Aussi important que le reste      Equilibre\n4  Appartenance sans pratique Moins important que le reste   Satisfaction\n5         Pratiquant regulier                         <NA>           <NA>\n6 Ni croyance ni appartenance            Le plus important      Equilibre\n  hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1       Non        Non          Non     Oui    Non    Non   Non         0\n2       Non        Non          Non     Non    Non    Oui   Oui         1\n3       Non        Non          Non     Non    Non    Non   Oui         0\n4       Non        Non          Non     Oui    Oui    Oui   Oui         2\n5       Non        Non          Non     Non    Non    Non   Non         3\n6       Non        Non          Non     Non    Non    Oui   Oui         2\n\ntail(hdv2003, 2)\n\n       id age  sexe                                       nivetud     poids\n1999 1999  24 Femme Enseignement technique ou professionnel court 13740.810\n2000 2000  66 Femme  Enseignement technique ou professionnel long  7709.513\n                     occup  qualif freres.soeurs clso\n1999 Exerce une profession Employe             2  Non\n2000              Au foyer Employe             3  Non\n                          relig                     trav.imp trav.satisf\n1999 Appartenance sans pratique Moins important que le reste   Equilibre\n2000 Appartenance sans pratique                         <NA>        <NA>\n     hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1999       Non        Non          Non     Non    Non    Oui   Non       0.3\n2000       Non        Oui          Non     Oui    Non    Non   Non       0.0\n\n\nL’extension dplyr propose une fonction dplyr::glimpse() (ce qui signifie aperçu en anglais) qui permet de visualiser rapidement et de manière condensée le contenu d’un tableau de données.\n\nlibrary(dplyr)\nglimpse(hdv2003)\n\nRows: 2,000\nColumns: 20\n$ id            <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1…\n$ age           <int> 28, 23, 59, 34, 71, 35, 60, 47, 20, 28, 65, 47, 63, 67, …\n$ sexe          <fct> Femme, Femme, Homme, Homme, Femme, Femme, Femme, Homme, …\n$ nivetud       <fct> \"Enseignement superieur y compris technique superieur\", …\n$ poids         <dbl> 2634.3982, 9738.3958, 3994.1025, 5731.6615, 4329.0940, 8…\n$ occup         <fct> \"Exerce une profession\", \"Etudiant, eleve\", \"Exerce une …\n$ qualif        <fct> Employe, NA, Technicien, Technicien, Employe, Employe, O…\n$ freres.soeurs <int> 8, 2, 2, 1, 0, 5, 1, 5, 4, 2, 3, 4, 1, 5, 2, 3, 4, 0, 2,…\n$ clso          <fct> Oui, Oui, Non, Non, Oui, Non, Oui, Non, Oui, Non, Oui, O…\n$ relig         <fct> Ni croyance ni appartenance, Ni croyance ni appartenance…\n$ trav.imp      <fct> Peu important, NA, Aussi important que le reste, Moins i…\n$ trav.satisf   <fct> Insatisfaction, NA, Equilibre, Satisfaction, NA, Equilib…\n$ hard.rock     <fct> Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, N…\n$ lecture.bd    <fct> Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, N…\n$ peche.chasse  <fct> Non, Non, Non, Non, Non, Non, Oui, Oui, Non, Non, Non, N…\n$ cuisine       <fct> Oui, Non, Non, Oui, Non, Non, Oui, Oui, Non, Non, Oui, N…\n$ bricol        <fct> Non, Non, Non, Oui, Non, Non, Non, Oui, Non, Non, Oui, O…\n$ cinema        <fct> Non, Oui, Non, Oui, Non, Oui, Non, Non, Oui, Oui, Oui, N…\n$ sport         <fct> Non, Oui, Oui, Oui, Non, Oui, Non, Non, Non, Oui, Non, O…\n$ heures.tv     <dbl> 0.0, 1.0, 0.0, 2.0, 3.0, 2.0, 2.9, 1.0, 2.0, 2.0, 1.0, 0…\n\n\nL’extension labelled propose une fonction labelled::look_for() qui permet de lister les différentes variables d’un fichier de données :\n\nlibrary(labelled)\nlook_for(hdv2003)\n\n pos variable      label col_type values                                     \n 1   id            —     int                                                 \n 2   age           —     int                                                 \n 3   sexe          —     fct      Homme                                      \n                                  Femme                                      \n 4   nivetud       —     fct      N'a jamais fait d'etudes                   \n                                  A arrete ses etudes, avant la derniere ann~\n                                  Derniere annee d'etudes primaires          \n                                  1er cycle                                  \n                                  2eme cycle                                 \n                                  Enseignement technique ou professionnel co~\n                                  Enseignement technique ou professionnel lo~\n                                  Enseignement superieur y compris technique~\n 5   poids         —     dbl                                                 \n 6   occup         —     fct      Exerce une profession                      \n                                  Chomeur                                    \n                                  Etudiant, eleve                            \n                                  Retraite                                   \n                                  Retire des affaires                        \n                                  Au foyer                                   \n                                  Autre inactif                              \n 7   qualif        —     fct      Ouvrier specialise                         \n                                  Ouvrier qualifie                           \n                                  Technicien                                 \n                                  Profession intermediaire                   \n                                  Cadre                                      \n                                  Employe                                    \n                                  Autre                                      \n 8   freres.soeurs —     int                                                 \n 9   clso          —     fct      Oui                                        \n                                  Non                                        \n                                  Ne sait pas                                \n 10  relig         —     fct      Pratiquant regulier                        \n                                  Pratiquant occasionnel                     \n                                  Appartenance sans pratique                 \n                                  Ni croyance ni appartenance                \n                                  Rejet                                      \n                                  NSP ou NVPR                                \n 11  trav.imp      —     fct      Le plus important                          \n                                  Aussi important que le reste               \n                                  Moins important que le reste               \n                                  Peu important                              \n 12  trav.satisf   —     fct      Satisfaction                               \n                                  Insatisfaction                             \n                                  Equilibre                                  \n 13  hard.rock     —     fct      Non                                        \n                                  Oui                                        \n 14  lecture.bd    —     fct      Non                                        \n                                  Oui                                        \n 15  peche.chasse  —     fct      Non                                        \n                                  Oui                                        \n 16  cuisine       —     fct      Non                                        \n                                  Oui                                        \n 17  bricol        —     fct      Non                                        \n                                  Oui                                        \n 18  cinema        —     fct      Non                                        \n                                  Oui                                        \n 19  sport         —     fct      Non                                        \n                                  Oui                                        \n 20  heures.tv     —     dbl                                                 \n\n\nLorsqu’on a un gros tableau de données avec de nombreuses variables, il peut être difficile de retrouver la ou les variables d’intérêt. Il est possible d’indiquer à labelled::look_for() un mot-clé pour limiter la recherche. Par exemple :\n\nlook_for(hdv2003, \"trav\")\n\n pos variable    label col_type values                      \n 11  trav.imp    —     fct      Le plus important           \n                                Aussi important que le reste\n                                Moins important que le reste\n                                Peu important               \n 12  trav.satisf —     fct      Satisfaction                \n                                Insatisfaction              \n                                Equilibre                   \n\n\nIl est à noter que si la recherche n’est pas sensible à la casse (i.e. aux majuscules et aux minuscules), elle est sensible aux accents.\nLa méthode summary() qui fonctionne sur tout type d’objet permet d’avoir quelques statistiques de base sur les différentes variables de notre tableau, les statistiques affichées dépendant du type de variable.\n\nsummary(hdv2003)\n\n       id              age           sexe     \n Min.   :   1.0   Min.   :18.00   Homme: 899  \n 1st Qu.: 500.8   1st Qu.:35.00   Femme:1101  \n Median :1000.5   Median :48.00               \n Mean   :1000.5   Mean   :48.16               \n 3rd Qu.:1500.2   3rd Qu.:60.00               \n Max.   :2000.0   Max.   :97.00               \n                                              \n                                                 nivetud        poids         \n Enseignement technique ou professionnel court       :463   Min.   :   78.08  \n Enseignement superieur y compris technique superieur:441   1st Qu.: 2221.82  \n Derniere annee d'etudes primaires                   :341   Median : 4631.19  \n 1er cycle                                           :204   Mean   : 5535.61  \n 2eme cycle                                          :183   3rd Qu.: 7626.53  \n (Other)                                             :256   Max.   :31092.14  \n NA's                                                :112                     \n                   occup                           qualif    freres.soeurs   \n Exerce une profession:1049   Employe                 :594   Min.   : 0.000  \n Chomeur              : 134   Ouvrier qualifie        :292   1st Qu.: 1.000  \n Etudiant, eleve      :  94   Cadre                   :260   Median : 2.000  \n Retraite             : 392   Ouvrier specialise      :203   Mean   : 3.283  \n Retire des affaires  :  77   Profession intermediaire:160   3rd Qu.: 5.000  \n Au foyer             : 171   (Other)                 :144   Max.   :22.000  \n Autre inactif        :  83   NA's                    :347                   \n          clso                              relig    \n Oui        : 936   Pratiquant regulier        :266  \n Non        :1037   Pratiquant occasionnel     :442  \n Ne sait pas:  27   Appartenance sans pratique :760  \n                    Ni croyance ni appartenance:399  \n                    Rejet                      : 93  \n                    NSP ou NVPR                : 40  \n                                                     \n                         trav.imp           trav.satisf  hard.rock  lecture.bd\n Le plus important           : 29   Satisfaction  :480   Non:1986   Non:1953  \n Aussi important que le reste:259   Insatisfaction:117   Oui:  14   Oui:  47  \n Moins important que le reste:708   Equilibre     :451                        \n Peu important               : 52   NA's          :952                        \n NA's                        :952                                             \n                                                                              \n                                                                              \n peche.chasse cuisine    bricol     cinema     sport        heures.tv     \n Non:1776     Non:1119   Non:1147   Non:1174   Non:1277   Min.   : 0.000  \n Oui: 224     Oui: 881   Oui: 853   Oui: 826   Oui: 723   1st Qu.: 1.000  \n                                                          Median : 2.000  \n                                                          Mean   : 2.247  \n                                                          3rd Qu.: 3.000  \n                                                          Max.   :12.000  \n                                                          NA's   :5       \n\n\nOn peut également appliquer summary() à une variable particulière.\n\nsummary(hdv2003$sexe)\n\nHomme Femme \n  899  1101 \n\nsummary(hdv2003$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  18.00   35.00   48.00   48.16   60.00   97.00"
  },
  {
    "objectID": "bases/tableaux_donnees.html#en-résumé",
    "href": "bases/tableaux_donnees.html#en-résumé",
    "title": "4  Tableaux de données",
    "section": "\n4.4 En résumé",
    "text": "4.4 En résumé\n\nLes tableaux de données sont des listes avec des propriétés particulières :\n\ntous les éléments sont des vecteurs ;\ntous les vecteurs ont la même longueur ;\ntous les vecteurs ont un nom et ce nom est unique.\n\n\nOn peut créer un tableau de données avec data.frame().\nLes tableaux de données correspondent aux fichiers de données qu’on utilise usuellement dans d’autres logiciels de statistiques : les variables sont représentées en colonnes et les observations en lignes.\nCe sont des objets bidimensionnels : ncol() renvoie le nombre de colonnes et nrow() le nombre de lignes.\nLes doubles crochets ([[]]) et le symbole dollar ($) fonctionnent comme pour les listes et permettent d’accéder aux variables.\nIl est possible d’utiliser des coordonnées bidimensionnelles avec les crochets simples ([]) en indiquant un critère sur les lignes puis un critère sur les colonnes, séparés par une virgule (,)."
  },
  {
    "objectID": "bases/tableaux_donnees.html#webin-r",
    "href": "bases/tableaux_donnees.html#webin-r",
    "title": "4  Tableaux de données",
    "section": "\n4.5 webin-R",
    "text": "4.5 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "bases/tibbles.html",
    "href": "bases/tibbles.html",
    "title": "5  Tibbles",
    "section": "",
    "text": "Le tidyverse est en partie fondé sur le concept de tidy data, développé à l’origine par Hadley Wickham dans un article de 2014 du Journal of Statistical Software.\nIl s’agit d’un modèle d’organisation des données qui vise à faciliter le travail souvent long et fastidieux de nettoyage et de préparation préalable à la mise en oeuvre de méthodes d’analyse.\nLes principes d’un jeu de données tidy sont les suivants :\n\nchaque variable est une colonne\nchaque observation est une ligne\nchaque type d’observation est dans une table différente\n\nUn chapitre dédié à tidyr (voir Chapitre 10) présente comment définir et rendre des données tidy avec ce package.\nLes extensions du tidyverse, notamment ggplot2 et dplyr, sont prévues pour fonctionner avec des données tidy."
  },
  {
    "objectID": "bases/tibbles.html#tibbles",
    "href": "bases/tibbles.html#tibbles",
    "title": "5  Tibbles",
    "section": "\n5.2 tibbles : des tableaux de données améliorés",
    "text": "5.2 tibbles : des tableaux de données améliorés\nUne autre particularité du tidyverse est que ces extensions travaillent avec des tableaux de données au format tibble::tibble(), qui est une évolution plus moderne du classique data.frame de R de base.\nCe format est fourni est géré par l’extension du même nom (tibble), qui fait partie du coeur du tidyverse. La plupart des fonctions des extensions du tidyverse acceptent des data.frames en entrée, mais retournent un tibble.\nContrairement aux data frames, les tibbles :\n\nn’ont pas de noms de lignes (rownames)\nautorisent des noms de colonnes invalides pour les data frames (espaces, caractères spéciaux, nombres…) 1\n\ns’affichent plus intelligemment que les data frames : seules les premières lignes sont affichées, ainsi que quelques informations supplémentaires utiles (dimensions, types des colonnes…)\nne font pas de partial matching sur les noms de colonnes 2\n\naffichent un avertissement si on essaie d’accéder à une colonne qui n’existe pas\n\n1 Quand on veut utiliser des noms de ce type, on doit les entourer avec des backticks (`)2 Dans R base, si une table d contient une colonne qualif, d$qual retournera cette colonne.Pour autant, les tibbles restent compatibles avec les data frames.\nIl est possible de créer un tibble manuellement avec tibble::tibble().\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\ntibble(\n  x = c(1.2345, 12.345, 123.45, 1234.5, 12345),\n  y = c(\"a\", \"b\", \"c\", \"d\", \"e\")\n)\n\n# A tibble: 5 × 2\n         x y    \n     <dbl> <chr>\n1     1.23 a    \n2    12.3  b    \n3   123.   c    \n4  1234.   d    \n5 12345    e    \n\n\nOn peut ainsi facilement convertir un data frame en tibble avec tibble::as_tibble() :\n\nd <- as_tibble(mtcars)\nd\n\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\nD’ailleurs, quand on regarde la classe d’un tibble, on peut s’apercevoir qu’un tibble hérite de la classe data.frame mais possède en plus la classe tbl_df. Cela traduit bien le fait que les tibbles restent des data frames.\n\nclass(d)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nSi le data frame d’origine a des rownames, on peut d’abord les convertir en colonnes avec tibble::rownames_to_columns() :\n\nd <- as_tibble(rownames_to_column(mtcars))\nd\n\n# A tibble: 32 × 12\n   rowname       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <chr>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\n\nÀ l’inverse, on peut à tout moment convertir un tibble en data frame avec tibble::as.data.frame() :\n\nas.data.frame(d)\n\n               rowname  mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n1            Mazda RX4 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n2        Mazda RX4 Wag 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n3           Datsun 710 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n4       Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n5    Hornet Sportabout 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n6              Valiant 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n7           Duster 360 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n8            Merc 240D 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n9             Merc 230 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n10            Merc 280 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n11           Merc 280C 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n12          Merc 450SE 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n13          Merc 450SL 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n14         Merc 450SLC 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n15  Cadillac Fleetwood 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n16 Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n17   Chrysler Imperial 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n18            Fiat 128 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n19         Honda Civic 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n20      Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n21       Toyota Corona 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n22    Dodge Challenger 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n23         AMC Javelin 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n24          Camaro Z28 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n25    Pontiac Firebird 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n26           Fiat X1-9 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n27       Porsche 914-2 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n28        Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n29      Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n30        Ferrari Dino 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n31       Maserati Bora 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n32          Volvo 142E 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nLà encore, on peut convertir la colonne rowname en “vrais” rownames avec tibble::column_to_rownames() :\n\ncolumn_to_rownames(as.data.frame(d))\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\n\n\n\n\n\nNote\n\n\n\nLes deux fonctions tibble::column_to_rownames() et tibble::rownames_to_column() acceptent un argument supplémentaire var qui permet d’indiquer un nom de colonne autre que le nom rowname utilisé par défaut pour créer ou identifier la colonne contenant les noms de lignes."
  },
  {
    "objectID": "bases/tibbles.html#données-et-tableaux-imbriqués",
    "href": "bases/tibbles.html#données-et-tableaux-imbriqués",
    "title": "5  Tibbles",
    "section": "\n5.3 Données et tableaux imbriqués",
    "text": "5.3 Données et tableaux imbriqués\nUne des particularités des tibbles est qu’ils acceptent, à la différence des data frames, des colonnes composées de listes et, par extension, d’autres tibbles (qui sont des listes)  !\n\nd <- tibble(\n  g = c(1, 2, 3),\n  data = list(\n    tibble(x = 1, y = 2),\n    tibble(x = 4:5, y = 6:7),\n    tibble(x = 10)\n  )\n)\nd\n\n# A tibble: 3 × 2\n      g data            \n  <dbl> <list>          \n1     1 <tibble [1 × 2]>\n2     2 <tibble [2 × 2]>\n3     3 <tibble [1 × 1]>\n\nd$data[[2]]\n\n# A tibble: 2 × 2\n      x     y\n  <int> <int>\n1     4     6\n2     5     7\n\n\nCette fonctionalité, combinée avec les fonctions de tidyr et de purrr, s’avère très puissante pour réaliser des opérations multiples en peu de ligne de code.\nDans l’exemple ci-dessous, nous réalisons des régressions linéaires par sous-groupe et les présentons dans un même tableau. Pour le moment, le code présenté doit vous sembler complexe et un peu obscur. Pas de panique : tout cela sera clarifié dans les differents chapitres de ce guide. Ce qu’il y a à retenir pour le moment, c’est la possibilité de stocker, dans les colonnes d’un tibble, différent types de données, y compris des sous-tableaux, des résultats de modèles et même des tableaux mis en forme.\n\nreg <-\n  iris |> \n  group_by(Species) |> \n  nest() |> \n  mutate(\n    model = map(\n      data, \n      ~ lm(Sepal.Length ~ Petal.Length + Petal.Width, data = .)\n    ),\n    tbl = map(model, gtsummary::tbl_regression)\n  )\nreg\n\n# A tibble: 3 × 4\n# Groups:   Species [3]\n  Species    data              model  tbl       \n  <fct>      <list>            <list> <list>    \n1 setosa     <tibble [50 × 4]> <lm>   <tbl_rgrs>\n2 versicolor <tibble [50 × 4]> <lm>   <tbl_rgrs>\n3 virginica  <tibble [50 × 4]> <lm>   <tbl_rgrs>\n\ngtsummary::tbl_merge(\n  reg$tbl,\n  tab_spanner = paste0(\"**\", reg$Species, \"**\")\n)\n\n\n\n\n\n\n\nCharacteristic\n      \n        setosa\n      \n      \n        versicolor\n      \n      \n        virginica\n      \n    \n\nBeta\n      \n95% CI1\n\n      p-value\n      Beta\n      \n95% CI1\n\n      p-value\n      Beta\n      \n95% CI1\n\n      p-value\n    \n\n\n\nPetal.Length\n0.40\n-0.20, 1.0\n0.2\n0.93\n0.59, 1.3\n<0.001\n1.0\n0.81, 1.2\n<0.001\n\n\nPetal.Width\n0.71\n-0.27, 1.7\n0.2\n-0.32\n-1.1, 0.49\n0.4\n0.01\n-0.35, 0.37\n>0.9\n\n\n\n\n1 CI = Confidence Interval"
  },
  {
    "objectID": "bases/attributs.html",
    "href": "bases/attributs.html",
    "title": "6  Attributs",
    "section": "",
    "text": "Parmi les attributs les plus courants, on retrouve nottament :\n\n\nclass : la classe de l’objet\n\nlenghth : sa longueur\n\nnames : les noms donnés aux éléments de l’objet\n\nlevels : pour les facteurs, les étiquettes des différents niveaux\n\nlabel : une étiquette de variable\n\nLa fonction attributes() permet de lister tous les attributs associés à un objet.\n\nattributes(iris)\n\n$names\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150\n\n\nPour accéder à un attribut spécifique, on aura recours à attr() en spéficiant à la fois l’objet considéré et le nom de l’attribut souhaité.\n\niris |> attr(\"names\")\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\nPour les attributs les plus courants de R, il faut noter qu’il existe le plus souvent des fonctions spécifiques, comme class(), names() ou row.names().\n\nclass(iris)\n\n[1] \"data.frame\"\n\nnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\nLa fonction attr(), associée à l’opérateur d’assignation (<-) permet également de définir ses propres attributs.\n\nattr(iris, \"perso\") <- \"Des notes personnelles\"\nattributes(iris)\n\n$names\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150\n\n$perso\n[1] \"Des notes personnelles\"\n\nattr(iris, \"perso\")\n\n[1] \"Des notes personnelles\""
  },
  {
    "objectID": "manipulation/pipe.html",
    "href": "manipulation/pipe.html",
    "title": "7  Le pipe",
    "section": "",
    "text": "Il est fréquent d’enchainer des opérations en appelant successivement des fonctions sur le résultat de l’appel précédent.\nPrenons un exemple. Supposons que nous ayons un vecteur numérique v dont nous voulons calculer la moyenne puis l’afficher via un message dans la console. Pour un meilleur rendu, nous allons arrondir la moyenne à une décimale, mettre en forme le résultat à la française, c’est-à-dire avec la virgule comme séparateur des décimales, créer une phrase avec le résultat, puis l’afficher dans la console. Voici le code correspondant, étape par étape.\nCette écriture, n’est pas vraiment optimale, car cela entraine la création d’un grand nombre de variables intermédiaires totalement inutiles. Nous pourrions dès lors imbriquer les différentes fonctions les unes dans les autres :\nNous obtenons bien le même résultat, mais la lecture de cette ligne de code est assez difficile et il n’est pas aisé de bien identifier à quelle fonction est rattaché chaque argument.\nUne amélioration possible serait d’effectuer des retours à la ligne avec une indentation adéquate pour rendre cela plus lisible.\nC’est déjà mieux, mais toujours pas optimal."
  },
  {
    "objectID": "manipulation/pipe.html#le-pipe-natif-de-r",
    "href": "manipulation/pipe.html#le-pipe-natif-de-r",
    "title": "7  Le pipe",
    "section": "\n7.1 Le pipe natif de R : |>\n",
    "text": "7.1 Le pipe natif de R : |>\n\nDepuis la version 4.1, R a introduit ce que l’on nomme un pipe (tuyau en anglais), un nouvel opérateur noté |>.\nLe principe de cet opérateur est de passer l’élément situé à sa gauche comme premier argument de la fonction située à sa droite. Ainsi, l’écriture x |> f() est équivalente à f(x) et l’écriture x |> f(y) à f(x, y).\nParfois, on souhaite passer l’objet x à un autre endroit de la fonction f() que le premier argument. Depuis la version 4.2, R a introduit l’opérateur _,que l’on nomme un placeholder, pour indiquer où passer l’objet de gauche. Ainsi, x |> f(y, a = _) devient équivalent à f(y, a = x). ATTENTION : le placeholder doit impérativement être transmis à un argument nommé !\nTout cela semble encore un peu abstrait ? Reprenons notre exemple précédent et réécrivons le code avec le pipe.\n\nv |> \n  mean() |> \n  round(digits = 1) |> \n  format(decimal.mark = \",\") |> \n  paste0(\"La moyenne est de \", m = _, \".\") |> \n  message()\n\nLa moyenne est de 6,7.\n\n\nLe code n’est-il pas plus lisible ?\n\nLe diaporama ci-dessous vous permet de visualiser chaque étape du code."
  },
  {
    "objectID": "manipulation/pipe.html#le-pipe-du-tidyverse",
    "href": "manipulation/pipe.html#le-pipe-du-tidyverse",
    "title": "7  Le pipe",
    "section": "\n7.2 Le pipe du tidyverse : %>%\n",
    "text": "7.2 Le pipe du tidyverse : %>%\n\nCe n’est qu’à partir de la version 4.1 sortie en 2021 que R a proposé de manière native un pipe, en l’occurence l’opérateur |>.\nEn cela, R s’est notamment inspiré d’un opérateur similaire introduit dès 2014 dans le tidyverse. Le pipe du tidyverse fonctionne de manière similaire. Il est implémenté dans le package magrittr qui doit donc être chargé en mémoire. Le pipe est également disponible lorsque l’on effecture library(tidyverse).\nCet opérateur s’écrit %>% et il dispose lui aussi d’un placeholder qui est le .. La syntaxe du placeholder est un peu plus souple puisqu’il peut être passé à tout type d’argument, y compris un argument sans nom. Si l’on reprend notre exemple précédent.\n\nlibrary(magrittr)\nv %>% \n  mean() %>%\n  round(digits = 1) %>%\n  format(decimal.mark = \",\") %>%\n  paste0(\"La moyenne est de \", ., \".\") %>%\n  message()\n\nLa moyenne est de 6,7."
  },
  {
    "objectID": "manipulation/pipe.html#vaut-il-mieux-utiliser-ou",
    "href": "manipulation/pipe.html#vaut-il-mieux-utiliser-ou",
    "title": "7  Le pipe",
    "section": "\n7.3 Vaut-il mieux utiliser |> ou %>% ?",
    "text": "7.3 Vaut-il mieux utiliser |> ou %>% ?\n\n\n\n\nBonne question. Si vous utilisez une version récente de R (≥ 4.2), il est préférable d’avoir recours au pipe natif de R dans la mesure où il est plus efficient en termes de temps de calcul car il fait partie intégrante du langage. Dans ce guide, nous privilégeons d’ailleurs l’utilisation de |>.\nSi votre code nécessite de fonctionner avec différentes versions de R, par exemple dans le cadre d’un package, il est alors préférable, pour le moment, d’utiliser celui fourni par magrittr (%>%)."
  },
  {
    "objectID": "manipulation/pipe.html#accéder-à-un-élément-avec-purrrpluck-et-purrrchuck",
    "href": "manipulation/pipe.html#accéder-à-un-élément-avec-purrrpluck-et-purrrchuck",
    "title": "7  Le pipe",
    "section": "\n7.4 Accéder à un élément avec purrr::pluck() et purrr::chuck()\n",
    "text": "7.4 Accéder à un élément avec purrr::pluck() et purrr::chuck()\n\nIl est fréquent d’avoir besoin d’accéder à un élément précis d’une liste, d’un tableau ou d’un vecteur, ce que l’on fait d’ordinaire avec la syntaxe [[]] ou $ pour les listes ou [] pour les vecteurs. Cependant, cette syntaxe se combine souvent mal avec un enchaînement d’opérations utilisant le pipe.\nLe package purrr, chargé par défaut avec library(tidyverse), fournit une fonction purrr::pluck() qui, est l’équivalent de [[]], et qui permet de récupérer un élément par son nom ou sa position. Ainsi, si l’on considère le tableau de données iris, pluck(iris, \"Petal.Witdh\") est équivalent à iris$Petal.Width. Voyons un example d’utilisation dans le cadre d’un enchaînement d’opérations.\n\niris |> \n  purrr::pluck(\"Petal.Width\") |> \n  mean()\n\n[1] 1.199333\n\n\nCette écriture est équivalente à :\n\nmean(iris$Petal.Width)\n\n[1] 1.199333\n\n\npurrr::pluck() fonctionne également sur des vecteurs (et dans ce cas opère comme []).\n\nv <- c(\"a\", \"b\", \"c\", \"d\")\nv |> purrr::pluck(2)\n\n[1] \"b\"\n\nv[2]\n\n[1] \"b\"\n\n\nOn peut également, dans un même appel à purrr::pluck(), enchaîner plusieurs niveaux. Les trois syntaxes ci-après sont ainsi équivalents :\n\niris |> \n  purrr::pluck(\"Sepal.Width\", 3)\n\n[1] 3.2\n\niris |> \n  purrr::pluck(\"Sepal.Width\") |> \n  purrr::pluck(3)\n\n[1] 3.2\n\niris[[\"Sepal.Width\"]][3]\n\n[1] 3.2\n\n\nSi l’on demande un élément qui n’existe pas, purrr:pluck() renverra l’élement vide (NULL). Si l’on souhaite plutôt que cela génère une erreur, on aura alors recours à purrr::chuck().\n\niris |> purrr::pluck(\"inconnu\")\n\nNULL\n\niris |> purrr::chuck(\"inconnu\")\n\nError: Can't find name `inconnu` in vector\n\nv |> purrr::pluck(10)\n\nNULL\n\nv |> purrr::chuck(10)\n\nError: Index 1 exceeds the length of plucked object (10 > 4)"
  }
]