[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "guide-R",
    "section": "",
    "text": "Site en construction\n\n\n\nLe présent site est en cours de construction et sera complété dans les prochains mois.\nEn attendant, nous vous conseillons de consulter le site analyse-R.\n\n\nCe guide porte sur l’analyse de données d’enquêtes avec le logiciel R, un logiciel libre de statitistiques et de traitement de données. Les exemples présentés ici relèvent principalement du champs des sciences sociales quantitatives et des sciences de santé. Ils peuvent néanmoins s’appliquer à d’autre champs disciplinaires. Cependant, comme tout ouvrage, ce guide ne peut être exhaustif.\nCe guide présente comment réaliser des analyses statistiques et diverses opérations courantes (comme la manipulation de données ou la production de graphiques) avec R. Il ne s’agit pas d’un cours de statistiques : les différents chapitres présupposent donc que vous avez déjà une connaissance des différentes techniques présentées. Si vous souhaitez des précisions théoriques / méthodologiques à propos d’un certain type d’analyses, nous vous conseillons d’utiliser votre moteur de recherche préféré. En effet, on trouve sur internet de très nombreux supports de cours (sans compter les nombreux ouvrages spécialisés disponibles en librairie).\nDe même, il ne s’agit pas d’une introduction ou d’un guide pour les utilisatrices et utilisateurs débutant·es. Si vous découvrez R, nous vous conseillons la lecture de l’Introduction à R et au tidyverse de Julien Barnier (https://juba.github.io/tidyverse/). Vous pouvez également lire les chapitres introductifs d’analyse-R : Introduction à l’analyse d’enquêtes avec R et RStudio (https://larmarange.github.io/analyse-R/). Néanmoins, quelques rappels sur les bases du langage sont fournis dans la section Rappels.\nR disposent de nombreuses extensions ou packages (plus de 16000) et il existe souvent plusieurs manières de procéder pour arriver au même résultat. En particulier, en matière de manipulation de données, on oppose1 souvent base R qui repose sur les fonctions disponibles en standard dans R, la majorité étant fournies dans les packages {base}, {utils} ou encore {stats}, qui sont toujours chargés par défaut, et le tidyverse qui est une collection de packages comprenant, entre autres, dplyr, tibble, tidyr, forcats ou encore ggplot2. Il y a un débat ouvert, parfois passionné, sur le fait de privilégier l’une ou l’autre approche, et les avantages et inconvénients de chacune dépendent de nombreux facteurs, comme la lisibilité du code ou bien les performances en temps de calcul. Dans ce guide, nous avons adopté un point de vue pragmatique et utiliserons, le plus souvent mais pas exclusivement, les fonctions du tidyverse, de même que nous avons privilégié d’autres packages, comme gtsummary ou questionr par exemple pour la statistique descriptive. Cela ne signifie pas, pour chaque point abordé, qu’il s’agit de l’unique manière de procéder. Dans certains cas, il s’agit simplement de préférences personnelles.1 Une comparaison des deux syntaxes est illustrée par une vignette dédiée de dplyr.\nBien qu’il en reprenne de nombreux contenus, ce guide ne se substitue pas au site analyse-R. Il s’agit plutôt d’une version complémentaire qui a vocation à être plus structurée et parfois plus sélective dans les contenus présentés.\nEn complément, on pourra également se référer aux webin-R, une série de vidéos avec partage d’écran, librement accessibles sur Youtube : https://www.youtube.com/c/webinR.\nCette version du guide a utilisé R version 4.1.3 (2022-03-10). Ce document est généré avec quarto et le code source est disponible sur GitHub. Pour toute suggestion ou correction, vous pouvez ouvrir un ticket GitHub. Pour d’autres questions, vous pouvez utiliser les forums de discussion disponibles en bas de chaque page sur la version web du guide. Ce document est régulièrement mis à jour. La dernière version est consultable sur https://larmarange.github.io/guide-R/."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "guide-R",
    "section": "Remerciements",
    "text": "Remerciements\nCe document a bénéficié de différents apports provenant notamment de l’Introduction à R et de l’Introduction à R et au tidyverse de Julien Barnier et d’analyse-R : introduction à l’analyse d’enquêtes avec R et RStudio.\nMerci donc à Julien Barnier, Julien Biaudet, François Briatte, Milan Bouchet-Valat, Ewen Gallic, Frédérique Giraud, Joël Gombin, Mayeul Kauffmann, Christophe Lalanne & Nicolas Robette."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "guide-R",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International."
  },
  {
    "objectID": "rappels/index.html",
    "href": "rappels/index.html",
    "title": "Rappels",
    "section": "",
    "text": "Une bonne compréhension des bases du langage, bien qu’un peu ardue de prime abord, permet de comprendre le sens des commandes qu’on utilise et de pleinement exploiter la puissance que R offre en matière de manipulation de données."
  },
  {
    "objectID": "rappels/vecteurs.html",
    "href": "rappels/vecteurs.html",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "",
    "text": "Les vecteurs sont l’objet de base de R et correspondent à une liste de valeurs. Leurs propriétés fondamentales sont :"
  },
  {
    "objectID": "rappels/vecteurs.html#types-et-classes",
    "href": "rappels/vecteurs.html#types-et-classes",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.1 Types et classes",
    "text": "1.1 Types et classes\nDans R, il existe plusieurs types fondamentaux de vecteurs et, en particulier, :\n\nles nombres réels (c’est-à-dire les nombres décimaux1), par exemple 5.23 ;\nles nombres entiers, que l’on saisi en ajoutant le suffixe L2, par exemple 4L ;\nles chaînes de caractères (qui correspondent à du texte), que l’on saisit avec des guillemets doubles (\") ou simples (’), par exemple \"abc\" ;\nles valeurs logiques ou valeurs booléennes, à savoir vrai ou faux, que l’on représente avec les mots TRUE et FALSE (en majuscules3).\n\n1 Pour rappel, R étant anglophone, le caractère utilisé pour indiqué les chiffres après la virgule est le point (.).2 R utilise 32 bits pour représenter des nombres entiers, ce qui correspond en informatique à des entiers longs ou long integers en anglais, d’où la lettre L utilisée pour indiquer un nombre entier.3 On peut également utiliser les raccourcis T et F. Cependant, pour une meilleure lisibilité du code, il est préférable d’utiliser les versions longues TRUE et FALSE.En plus de ces types de base, il existe de nombreux autres types de vecteurs utilisés pour représenter toutes sortes de données, comme les facteurs (voir Chapitre 2) ou les dates (voir Chapitre 3).\nLa fonction class() renvoie la nature d’un vecteur tandis que la fonction typeof() indique la manière dont un vecteur est stocké de manière interne par R.\n\n\nTable 1.1: Le type et la classe des principaux types de vecteurs\n\n\n\n\n\n\nx\nclass(x)\ntypeof(x)\n\n\n\n3L\ninteger\ninteger\n\n\n5.3\nnumeric\ndouble\n\n\nTRUE\nlogical\nlogical\n\n\n\"abc\"\ncharacter\ncharacter\n\n\nfactor(\"a\")\nfactor\ninteger\n\n\nas.Date(\"2020-01-01\")\nDate\ndouble\n\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nPour un vecteur numérique, le type est \"double\" car R utilise une double précision pour stocker informatiquement les nombres réels.\nEn interne, les facteurs sont représentés par un nombre entier auquel est attaché une étiquette, c’est pourquoi typeof() renvoie \"integer\".\nQuand aux dates, elles sont stockées en interne sous la forme d’un nombre réel représentant le nombre de jours depuis le 1er janvier 1970, d’où le fait que typeof() renvoie \"double\"."
  },
  {
    "objectID": "rappels/vecteurs.html#création-dun-vecteur",
    "href": "rappels/vecteurs.html#création-dun-vecteur",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.2 Création d’un vecteur",
    "text": "1.2 Création d’un vecteur\nPour créer un vecteur, on utilisera la fonction c() en lui passant la liste des valeurs à combiner4.4 La lettre c est un raccourci du mot anglais combine, puisque cette fonction permet de combiner des valeurs individuelles dans un vecteur unique.\n\ntaille <- c(1.88, 1.65, 1.92, 1.76)\ntaille\n\n[1] 1.88 1.65 1.92 1.76\n\nsexe <- c(\"h\", \"f\", \"h\", \"f\")\nsexe\n\n[1] \"h\" \"f\" \"h\" \"f\"\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE)\nurbain\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nNous l’avons vu, toutes les valeurs d’un vecteur doivent obligatoirement être du même type. Dès lors, si on essaie de combiner des valeurs de différents types, R essaiera de les convertir au mieux. Par exemple :\n\nx <- c(2L, 3.14, \"a\")\nx\n\n[1] \"2\"    \"3.14\" \"a\"   \n\nclass(x)\n\n[1] \"character\"\n\n\nDans le cas présent, toutes les valeurs ont été converties en chaînes de caractères.\nDans certaines situations, on peut avoir besoin de créer un vecteur d’une certaine longueur mais dont toutes les valeurs sont identiques. Cela se réalise facilement avec rep() à qui on indiquera la valeur à répéter puis le nombre de répétitions :\n\nrep(2, 10)\n\n [1] 2 2 2 2 2 2 2 2 2 2\n\n\nOn peut aussi lui indiquer plusieurs valeurs qui seront alors répétées en boucle :\n\nrep(c(\"a\", \"b\"), 3)\n\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n\n\nDans d’autres situations, on peut avoir besoin de créer un vecteur contenant une suite de valeurs, ce qui se réalise aisément avec seq() à qui on précisera les arguments from (point de départ), to (point d’arrivée) et by (pas). Quelques exemples valent mieux qu’un long discours :\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(5, 17, by = 2)\n\n[1]  5  7  9 11 13 15 17\n\nseq(10, 0)\n\n [1] 10  9  8  7  6  5  4  3  2  1  0\n\nseq(100, 10, by = -10)\n\n [1] 100  90  80  70  60  50  40  30  20  10\n\nseq(1.23, 5.67, by = 0.33) \n\n [1] 1.23 1.56 1.89 2.22 2.55 2.88 3.21 3.54 3.87 4.20 4.53 4.86 5.19 5.52\n\n\nL’opérateur : est un raccourci de la fonction seq() pour créer une suite de nombres entiers. Il s’utilise ainsi :\n\n1:5\n\n[1] 1 2 3 4 5\n\n24:32\n\n[1] 24 25 26 27 28 29 30 31 32\n\n55:43\n\n [1] 55 54 53 52 51 50 49 48 47 46 45 44 43"
  },
  {
    "objectID": "rappels/vecteurs.html#longueur-dun-vecteur",
    "href": "rappels/vecteurs.html#longueur-dun-vecteur",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.3 Longueur d’un vecteur",
    "text": "1.3 Longueur d’un vecteur\nUn vecteur dispose donc d’une longueur qui correspond au nombre de valeurs qui le composent. Elle s’obtient avec length() :\n\nlength(taille)\n\n[1] 4\n\nlength(c(\"a\", \"b\"))\n\n[1] 2\n\n\nIl est possible de faire un vecteur de longueur nulle avec c(). Bien évidemment sa longueur est zéro.\n\nlength(c())\n\n[1] 0"
  },
  {
    "objectID": "rappels/vecteurs.html#combiner-des-vecteurs",
    "href": "rappels/vecteurs.html#combiner-des-vecteurs",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.4 Combiner des vecteurs",
    "text": "1.4 Combiner des vecteurs\nPour combiner des vecteurs, rien de plus simple. Il suffit d’utiliser c() ! Les valeurs des différents vecteurs seront mises bout à bout pour créer un unique vecteur.\n\nx <- c(2, 1, 3, 4)\nlength(x)\n\n[1] 4\n\ny <- c(9, 1, 2, 6, 3, 0)\nlength(y)\n\n[1] 6\n\nz <- c(x, y)\nz\n\n [1] 2 1 3 4 9 1 2 6 3 0\n\nlength(z)\n\n[1] 10"
  },
  {
    "objectID": "rappels/vecteurs.html#valeurs-manquantes",
    "href": "rappels/vecteurs.html#valeurs-manquantes",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.5 Valeurs manquantes",
    "text": "1.5 Valeurs manquantes\nLorsqu’on travaille avec des données d’enquête, il est fréquent que certaines données soient manquantes, en raison d’un refus du participant de répondre à une question donnée ou d’un oubli ou d’un dysfonctionnement du matériel de mesure, etc.\nUne valeur manquante s’indique sous R avec NA (pour not available). Cette valeur peut s’appliquer à n’importe quel type de vecteur, qu’il soit numérique, textuel ou logique.\n\ntaille <- c(1.88, NA, 1.65, 1.92, 1.76, NA)\nsexe <- c(\"h\", \"f\", NA, \"h\", NA, \"f\")\n\nLes valeurs manquantes sont prises en compte dans le calcul de la longueur du vecteur.\n\nlength(taille)\n\n[1] 6\n\n\nIl ne faut pas confondre NA avec un autre objet qu’on rencontre sous R qui s’appelle NULL et qui représente l’objet vide. NULL ne contient absolument rien. La différence se comprend mieux lorsqu’on essaie de combiner ces objets.\nOn peut combiner NULL avec NULL, du vide plus du vide renverra toujours du vide dont la dimension est égale à zéro.\n\nc(NULL, NULL, NULL)\n\nNULL\n\nlength(c(NULL, NULL, NULL))\n\n[1] 0\n\n\nPar contre, un vecteur composé de trois valeurs manquantes a une longueur de 3, même si toutes ses valeurs sont manquantes.\n\nc(NA, NA, NA)\n\n[1] NA NA NA\n\nlength(c(NA, NA, NA))\n\n[1] 3"
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-position",
    "href": "rappels/vecteurs.html#indexation-par-position",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.6 Indexation par position",
    "text": "1.6 Indexation par position\nL’indexation est l’une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de R. Il s’agit d’opérations permettant de sélectionner des sous-ensembles de valeurs en fonction de différents critères. Il existe trois types d’indexation : (i) l’indexation par position, (ii) l’indexation par nom et (iii) l’indexation par condition. Le principe est toujours le même : on indique entre crochets5 ([]) ce qu’on souhaite garder ou non.5 Pour rappel, les crochets s’obtiennent sur un clavier français de type PC en appuyant sur la touche Alt Gr et la touche ( ou ).\nCommençons par l’indexation par position encore appelée indexation directe. Ce mode le plus simple d’indexation consiste à indiquer la position des éléments à conserver.\nReprenons notre vecteur taille :\n\ntaille\n\n[1] 1.88   NA 1.65 1.92 1.76   NA\n\n\nSi on souhaite le premier élément du vecteur, on peut faire :\n\ntaille[1]\n\n[1] 1.88\n\n\nSi on souhaite les trois premiers éléments ou les éléments 2, 5 et 6 :\n\ntaille[1:3]\n\n[1] 1.88   NA 1.65\n\ntaille[c(2, 5, 6)]\n\n[1]   NA 1.76   NA\n\n\nSi on veut le dernier élément :\n\ntaille[length(taille)]\n\n[1] NA\n\n\nIl est tout à fait possible de sélectionner les valeurs dans le désordre :\n\ntaille[c(5, 1, 4, 3)]\n\n[1] 1.76 1.88 1.92 1.65\n\n\nDans le cadre de l’indexation par position, il est également possible de spécifier des nombres négatifs, auquel cas cela signifiera toutes les valeurs sauf celles-là. Par exemple :\n\ntaille[c(-1, -5)]\n\n[1]   NA 1.65 1.92   NA\n\n\nÀ noter, si on indique une position au-delà de la longueur du vecteur, R renverra NA. Par exemple :\n\ntaille[23:25]\n\n[1] NA NA NA"
  },
  {
    "objectID": "rappels/vecteurs.html#des-vecteurs-nommés",
    "href": "rappels/vecteurs.html#des-vecteurs-nommés",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.7 Des vecteurs nommés",
    "text": "1.7 Des vecteurs nommés\nLes différentes valeurs d’un vecteur peuvent être nommées. Une première manière de nommer les éléments d’un vecteur est de le faire à sa création :\n\nsexe <- c(Michel = \"h\", Anne = \"f\", Dominique = NA, Jean = \"h\", Claude = NA, Marie = \"f\")\n\nLorsqu’on affiche le vecteur, la présentation change quelque peu.\n\nsexe\n\n   Michel      Anne Dominique      Jean    Claude     Marie \n      \"h\"       \"f\"        NA       \"h\"        NA       \"f\" \n\n\nLa liste des noms s’obtient avec names().\n\nnames(sexe)\n\n[1] \"Michel\"    \"Anne\"      \"Dominique\" \"Jean\"      \"Claude\"    \"Marie\"    \n\n\nPour ajouter ou modifier les noms d’un vecteur, on doit attribuer un nouveau vecteur de noms :\n\nnames(sexe) <- c(\"Michael\", \"Anna\", \"Dom\", \"John\", \"Alex\", \"Mary\")\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\n\nPour supprimer tous les noms, il y a la fonction unname() :\n\nanonyme <- unname(sexe)\nanonyme\n\n[1] \"h\" \"f\" NA  \"h\" NA  \"f\""
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-nom",
    "href": "rappels/vecteurs.html#indexation-par-nom",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.8 Indexation par nom",
    "text": "1.8 Indexation par nom\nLorsqu’un vecteur est nommé, il est dès lors possible d’accéder à ses valeurs à partir de leur nom. Il s’agit de l’indexation par nom.\n\nsexe[\"Anna\"]\n\nAnna \n \"f\" \n\nsexe[c(\"Mary\", \"Michael\", \"John\")]\n\n   Mary Michael    John \n    \"f\"     \"h\"     \"h\" \n\n\nPar contre il n’est pas possible d’utiliser l’opérateur - comme pour l’indexation directe. Pour exclure un élément en fonction de son nom, on doit utiliser une autre forme d’indexation, l’indexation par condition, expliquée dans la section suivante. On peut ainsi faire…\n\nsexe[names(sexe) != \"Dom\"]\n\n… pour sélectionner tous les éléments sauf celui qui s’appelle Dom."
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-condition",
    "href": "rappels/vecteurs.html#indexation-par-condition",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.9 Indexation par condition",
    "text": "1.9 Indexation par condition\nL’indexation par condition consiste à fournir un vecteur logique indiquant si chaque élément doit être inclus (si TRUE) ou exclu (si FALSE). Par exemple :\n\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\nsexe[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n\nMichael    John \n    \"h\"     \"h\" \n\n\nÉcrire manuellement une telle condition n’est pas très pratique à l’usage. Mais supposons que nous ayons également à notre disposition les deux vecteurs suivants, également de longueur 6.\n\nurbain <- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE)\npoids <- c(80, 63, 75, 87, 82, 67)\n\nLe vecteur urbain est un vecteur logique. On peut directement l’utiliser pour avoir le sexe des enquêtés habitant en milieu urbain :\n\nsexe[urbain]\n\nMichael    Alex    Mary \n    \"h\"      NA     \"f\" \n\n\nSupposons qu’on souhaite maintenant avoir la taille des individus pesant 80 kilogrammes ou plus. Nous pouvons effectuer une comparaison à l’aide des opérateurs de comparaison suivants :\n\n\nOpérateur de comparaison\nSignification\n\n\n\n==\négal à\n\n\n!=\ndifférent de\n\n\n>\nstrictement supérieur à\n\n\n<\nstrictement inférieur à\n\n\n>=\nsupérieur ou égal à\n\n\n<=\ninférieur ou égal à\n\n\n\nVoyons tout de suite un exemple :\n\npoids >= 80\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n\nQue s’est-il passé ? Nous avons fourni à R une condition et il nous a renvoyé un vecteur logique avec autant d’éléments qu’il y a d’observations et dont la valeur est TRUE si la condition est remplie et FALSE dans les autres cas. Nous pouvons alors utiliser ce vecteur logique pour obtenir la taille des participants pesant 80 kilogrammes ou plus :\n\ntaille[poids >= 80]\n\n[1] 1.88 1.92 1.76\n\n\nOn peut combiner ou modifier des conditions à l’aide des opérateurs logiques habituels :\n\n\nOpérateur logique\nSignification\n\n\n\n&\net logique\n\n\n|\nou logique\n\n\n!\nnégation logique\n\n\n\nComment les utilise-t-on ? Voyons tout de suite un exemple. Supposons que je veuille identifier les personnes pesant 80 kilogrammes ou plus et vivant en milieu urbain :\n\npoids >= 80 & urbain\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n\n\nLes résultats sont différents si je souhaite isoler les personnes pesant 80 kilogrammes ou plus ou vivant milieu urbain :\n\npoids >= 80 | urbain\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nUne remarque importante : quand l’un des termes d’une condition comporte une valeur manquante (NA), le résultat de cette condition n’est pas toujours TRUE ou FALSE, il peut aussi être à son tour une valeur manquante.\n\ntaille\n\n[1] 1.88   NA 1.65 1.92 1.76   NA\n\ntaille > 1.8\n\n[1]  TRUE    NA FALSE  TRUE FALSE    NA\n\n\nOn voit que le test NA > 1.8 ne renvoie ni vrai ni faux, mais NA.\nUne autre conséquence importante de ce comportement est qu’on ne peut pas utiliser l’opérateur l’expression == NA pour tester la présence de valeurs manquantes. On utilisera à la place la fonction ad hoc is.na() :\n\nis.na(taille > 1.8)\n\n[1] FALSE  TRUE FALSE FALSE FALSE  TRUE\n\n\nPour compliquer encore un peu le tout, lorsqu’on utilise une condition pour l’indexation, si la condition renvoie NA, R ne sélectionne pas l’élément mais retourne quand même la valeur NA. Ceci a donc des conséquences sur le résultat d’une indexation par comparaison.\nPar exemple si je cherche à connaître le poids des personnes mesurant 1,80 mètre ou plus :\n\ntaille\n\n[1] 1.88   NA 1.65 1.92 1.76   NA\n\npoids\n\n[1] 80 63 75 87 82 67\n\npoids[taille > 1.8]\n\n[1] 80 NA 87 NA\n\n\nLes éléments pour lesquels la taille n’est pas connue ont été transformés en NA, ce qui n’influera pas le calcul d’une moyenne. Par contre, lorsqu’on utilisera assignation et indexation ensemble, cela peut créer des problèmes. Il est donc préférable lorsqu’on a des valeurs manquantes de les exclure ainsi :\n\npoids[taille > 1.8 & !is.na(taille)]\n\n[1] 80 87"
  },
  {
    "objectID": "rappels/vecteurs.html#assignation-par-indexation",
    "href": "rappels/vecteurs.html#assignation-par-indexation",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.10 Assignation par indexation",
    "text": "1.10 Assignation par indexation\nDans tous les exemples précédents, on a utilisé l’indexation pour extraire une partie d’un vecteur, en plaçant l’opération d’indexation à droite de l’opérateur <-.\nMais l’indexation peut également être placée à gauche de cet opérateur d’assignation. Dans ce cas, les éléments sélectionnés par l’indexation sont alors remplacés par les valeurs indiquées à droite de l’opérateur <-.\nPrenons donc un exemple simple :\n\nv <- 1:5\nv\n\n[1] 1 2 3 4 5\n\nv[1] <- 3\nv\n\n[1] 3 2 3 4 5\n\n\nCette fois, au lieu d’utiliser quelque chose comme x <- v[1], qui aurait placé la valeur du premier élément de v dans x, on a utilisé v[1] <- 3, ce qui a mis à jour le premier élément de v avec la valeur 3. Ceci fonctionne également pour les différents types d’indexation évoqués précédemment :\n\nsexe[\"Alex\"] <- \"f\"\n\nEnfin on peut modifier plusieurs éléments d’un seul coup soit en fournissant un vecteur, soit en profitant du mécanisme de recyclage. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :\n\nsexe[c(1,3,4)] <- c(\"Homme\", \"Homme\", \"Homme\")\nsexe[c(1,3,4)] <- \"Homme\"\n\nL’assignation par indexation peut aussi être utilisée pour ajouter une ou plusieurs valeurs à un vecteur :\n\nlength(sexe)\n\n[1] 6\n\nsexe[7] <- \"f\"\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary         \n\"Homme\"     \"f\" \"Homme\" \"Homme\"     \"f\"     \"f\"     \"f\" \n\nlength(sexe)\n\n[1] 7"
  },
  {
    "objectID": "rappels/vecteurs.html#en-résumé",
    "href": "rappels/vecteurs.html#en-résumé",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.11 En résumé",
    "text": "1.11 En résumé\n\nUn vecteur est un objet unidimensionnel contenant une liste de valeurs qui sont toutes du même type (entières, numériques, textuelles ou logiques).\nLa fonction class() permet de connaître le type du vecteur et la fonction length() sa longueur, c’est-à-dire son nombre d’éléments.\nLa fonction c() sert à créer et à combiner des vecteurs.\nLes valeurs manquantes sont représentées avec NA.\nUn vecteur peut être nommé, c’est-à-dire qu’un nom textuel a été associé à chaque élément. Cela peut se faire lors de sa création ou avec la fonction names().\nL’indexation consiste à extraire certains éléments d’un vecteur. Pour cela, on indique ce qu’on souhaite extraire entre crochets ([]) juste après le nom du vecteur. Le type d’indexation dépend du type d’information transmise.\nS’il s’agit de nombres entiers, c’est l’indexation par position : les nombres représentent la position dans le vecteur des éléments qu’on souhaite extraire. Un nombre négatif s’interprète comme tous les éléments sauf celui-là.\nSi on indique des chaînes de caractères, c’est l’indexation par nom : on indique le nom des éléments qu’on souhaite extraire. Cette forme d’indexation ne fonctionne que si le vecteur est nommé.\nSi on transmet des valeurs logiques, le plus souvent sous la forme d’une condition, c’est l’indexation par condition : TRUE indique les éléments à extraire et FALSE les éléments à exclure. Il faut être vigilant aux valeurs manquantes (NA) dans ce cas précis.\nEnfin, il est possible de ne modifier que certains éléments d’un vecteur en ayant recours à la fois à l’indexation ([]) et à l’assignation (<-)."
  },
  {
    "objectID": "rappels/vecteurs.html#webin-r",
    "href": "rappels/vecteurs.html#webin-r",
    "title": "1  Vecteurs, indexation et assignation",
    "section": "\n1.12 webin-R",
    "text": "1.12 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  }
]