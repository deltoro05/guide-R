[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "guide-R",
    "section": "",
    "text": "Site en construction\n\n\n\nLe présent site est en cours de construction et sera complété dans les prochains mois.\nEn attendant, nous vous conseillons de consulter le site analyse-R.\n\n\nCe guide porte sur l’analyse de données d’enquêtes avec le logiciel R, un logiciel libre de statitistiques et de traitement de données. Les exemples présentés ici relèvent principalement du champs des sciences sociales quantitatives et des sciences de santé. Ils peuvent néanmoins s’appliquer à d’autre champs disciplinaires. Cependant, comme tout ouvrage, ce guide ne peut être exhaustif.\nCe guide présente comment réaliser des analyses statistiques et diverses opérations courantes (comme la manipulation de données ou la production de graphiques) avec R. Il ne s’agit pas d’un cours de statistiques : les différents chapitres présupposent donc que vous avez déjà une connaissance des différentes techniques présentées. Si vous souhaitez des précisions théoriques / méthodologiques à propos d’un certain type d’analyses, nous vous conseillons d’utiliser votre moteur de recherche préféré. En effet, on trouve sur internet de très nombreux supports de cours (sans compter les nombreux ouvrages spécialisés disponibles en librairie).\nDe même, il ne s’agit pas d’une introduction ou d’un guide pour les utilisatrices et utilisateurs débutant·es. Si vous découvrez R, nous vous conseillons la lecture de l’Introduction à R et au tidyverse de Julien Barnier (https://juba.github.io/tidyverse/). Vous pouvez également lire les chapitres introductifs d’analyse-R : Introduction à l’analyse d’enquêtes avec R et RStudio (https://larmarange.github.io/analyse-R/). Néanmoins, quelques rappels sur les bases du langage sont fournis dans la section Rappels. Une bonne compréhension des bases du langage, bien qu’un peu ardue de prime abord, permet de comprendre le sens des commandes qu’on utilise et de pleinement exploiter la puissance que R offre en matière de manipulation de données.\nR disposent de nombreuses extensions ou packages (plus de 16000) et il existe souvent plusieurs manières de procéder pour arriver au même résultat. En particulier, en matière de manipulation de données, on oppose1 souvent base R qui repose sur les fonctions disponibles en standard dans R, la majorité étant fournies dans les packages {base}, {utils} ou encore {stats}, qui sont toujours chargés par défaut, et le tidyverse qui est une collection de packages comprenant, entre autres, dplyr, tibble, tidyr, forcats ou encore ggplot2. Il y a un débat ouvert, parfois passionné, sur le fait de privilégier l’une ou l’autre approche, et les avantages et inconvénients de chacune dépendent de nombreux facteurs, comme la lisibilité du code ou bien les performances en temps de calcul. Dans ce guide, nous avons adopté un point de vue pragmatique et utiliserons, le plus souvent mais pas exclusivement, les fonctions du tidyverse, de même que nous avons privilégié d’autres packages, comme gtsummary ou questionr par exemple pour la statistique descriptive. Cela ne signifie pas, pour chaque point abordé, qu’il s’agit de l’unique manière de procéder. Dans certains cas, il s’agit simplement de préférences personnelles.1 Une comparaison des deux syntaxes est illustrée par une vignette dédiée de dplyr.\nBien qu’il en reprenne de nombreux contenus, ce guide ne se substitue pas au site analyse-R. Il s’agit plutôt d’une version complémentaire qui a vocation à être plus structurée et parfois plus sélective dans les contenus présentés.\nEn complément, on pourra également se référer aux webin-R, une série de vidéos avec partage d’écran, librement accessibles sur Youtube : https://www.youtube.com/c/webinR.\nCette version du guide a utilisé R version 4.1.3 (2022-03-10). Ce document est généré avec quarto et le code source est disponible sur GitHub. Pour toute suggestion ou correction, vous pouvez ouvrir un ticket GitHub. Pour d’autres questions, vous pouvez utiliser les forums de discussion disponibles en bas de chaque page sur la version web du guide. Ce document est régulièrement mis à jour. La dernière version est consultable sur https://larmarange.github.io/guide-R/."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "guide-R",
    "section": "Remerciements",
    "text": "Remerciements\nCe document a bénéficié de différents apports provenant notamment de l’Introduction à R et de l’Introduction à R et au tidyverse de Julien Barnier et d’analyse-R : introduction à l’analyse d’enquêtes avec R et RStudio.\nMerci donc à Julien Barnier, Julien Biaudet, François Briatte, Milan Bouchet-Valat, Ewen Gallic, Frédérique Giraud, Joël Gombin, Mayeul Kauffmann, Christophe Lalanne & Nicolas Robette."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "guide-R",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International."
  },
  {
    "objectID": "rappels/vecteurs.html",
    "href": "rappels/vecteurs.html",
    "title": "1  Vecteurs",
    "section": "",
    "text": "Les vecteurs sont l’objet de base de R et correspondent à une liste de valeurs. Leurs propriétés fondamentales sont :"
  },
  {
    "objectID": "rappels/vecteurs.html#types-et-classes",
    "href": "rappels/vecteurs.html#types-et-classes",
    "title": "1  Vecteurs",
    "section": "\n1.1 Types et classes",
    "text": "1.1 Types et classes\nDans R, il existe plusieurs types fondamentaux de vecteurs et, en particulier, :\n\nles nombres réels (c’est-à-dire les nombres décimaux1), par exemple 5.23 ;\nles nombres entiers, que l’on saisi en ajoutant le suffixe L2, par exemple 4L ;\nles chaînes de caractères (qui correspondent à du texte), que l’on saisit avec des guillemets doubles (\") ou simples ('), par exemple \"abc\" ;\nles valeurs logiques ou valeurs booléennes, à savoir vrai ou faux, que l’on représente avec les mots TRUE et FALSE (en majuscules3).\n\n1 Pour rappel, R étant anglophone, le caractère utilisé pour indiqué les chiffres après la virgule est le point (.).2 R utilise 32 bits pour représenter des nombres entiers, ce qui correspond en informatique à des entiers longs ou long integers en anglais, d’où la lettre L utilisée pour indiquer un nombre entier.3 On peut également utiliser les raccourcis T et F. Cependant, pour une meilleure lisibilité du code, il est préférable d’utiliser les versions longues TRUE et FALSE.En plus de ces types de base, il existe de nombreux autres types de vecteurs utilisés pour représenter toutes sortes de données, comme les facteurs (voir Chapitre 3) ou les dates (voir Chapitre 4).\nLa fonction class() renvoie la nature d’un vecteur tandis que la fonction typeof() indique la manière dont un vecteur est stocké de manière interne par R.\n\n\nTable 1.1: Le type et la classe des principaux types de vecteurs\n\n\n\n\n\n\nx\nclass(x)\ntypeof(x)\n\n\n\n3L\ninteger\ninteger\n\n\n5.3\nnumeric\ndouble\n\n\nTRUE\nlogical\nlogical\n\n\n\"abc\"\ncharacter\ncharacter\n\n\nfactor(\"a\")\nfactor\ninteger\n\n\nas.Date(\"2020-01-01\")\nDate\ndouble\n\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nPour un vecteur numérique, le type est \"double\" car R utilise une double précision pour stocker informatiquement les nombres réels.\nEn interne, les facteurs sont représentés par un nombre entier auquel est attaché une étiquette, c’est pourquoi typeof() renvoie \"integer\".\nQuand aux dates, elles sont stockées en interne sous la forme d’un nombre réel représentant le nombre de jours depuis le 1er janvier 1970, d’où le fait que typeof() renvoie \"double\"."
  },
  {
    "objectID": "rappels/vecteurs.html#création-dun-vecteur",
    "href": "rappels/vecteurs.html#création-dun-vecteur",
    "title": "1  Vecteurs",
    "section": "\n1.2 Création d’un vecteur",
    "text": "1.2 Création d’un vecteur\nPour créer un vecteur, on utilisera la fonction c() en lui passant la liste des valeurs à combiner4.4 La lettre c est un raccourci du mot anglais combine, puisque cette fonction permet de combiner des valeurs individuelles dans un vecteur unique.\n\ntaille <- c(1.88, 1.65, 1.92, 1.76, NA, 1.72)\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\nsexe <- c(\"h\", \"f\", \"h\", \"f\", \"f\", \"f\")\nsexe\n\n[1] \"h\" \"f\" \"h\" \"f\" \"f\" \"f\"\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\nurbain\n\n[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\n\n\nNous l’avons vu, toutes les valeurs d’un vecteur doivent obligatoirement être du même type. Dès lors, si on essaie de combiner des valeurs de différents types, R essaiera de les convertir au mieux. Par exemple :\n\nx <- c(2L, 3.14, \"a\")\nx\n\n[1] \"2\"    \"3.14\" \"a\"   \n\nclass(x)\n\n[1] \"character\"\n\n\nDans le cas présent, toutes les valeurs ont été converties en chaînes de caractères.\nDans certaines situations, on peut avoir besoin de créer un vecteur d’une certaine longueur mais dont toutes les valeurs sont identiques. Cela se réalise facilement avec rep() à qui on indiquera la valeur à répéter puis le nombre de répétitions :\n\nrep(2, 10)\n\n [1] 2 2 2 2 2 2 2 2 2 2\n\n\nOn peut aussi lui indiquer plusieurs valeurs qui seront alors répétées en boucle :\n\nrep(c(\"a\", \"b\"), 3)\n\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n\n\nDans d’autres situations, on peut avoir besoin de créer un vecteur contenant une suite de valeurs, ce qui se réalise aisément avec seq() à qui on précisera les arguments from (point de départ), to (point d’arrivée) et by (pas). Quelques exemples valent mieux qu’un long discours :\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(5, 17, by = 2)\n\n[1]  5  7  9 11 13 15 17\n\nseq(10, 0)\n\n [1] 10  9  8  7  6  5  4  3  2  1  0\n\nseq(100, 10, by = -10)\n\n [1] 100  90  80  70  60  50  40  30  20  10\n\nseq(1.23, 5.67, by = 0.33) \n\n [1] 1.23 1.56 1.89 2.22 2.55 2.88 3.21 3.54 3.87 4.20 4.53 4.86 5.19 5.52\n\n\nL’opérateur : est un raccourci de la fonction seq() pour créer une suite de nombres entiers. Il s’utilise ainsi :\n\n1:5\n\n[1] 1 2 3 4 5\n\n24:32\n\n[1] 24 25 26 27 28 29 30 31 32\n\n55:43\n\n [1] 55 54 53 52 51 50 49 48 47 46 45 44 43"
  },
  {
    "objectID": "rappels/vecteurs.html#longueur-dun-vecteur",
    "href": "rappels/vecteurs.html#longueur-dun-vecteur",
    "title": "1  Vecteurs",
    "section": "\n1.3 Longueur d’un vecteur",
    "text": "1.3 Longueur d’un vecteur\nLa longueur d’un vecteur correspond au nombre de valeurs qui le composent. Elle s’obtient avec length() :\n\nlength(taille)\n\n[1] 4\n\nlength(c(\"a\", \"b\"))\n\n[1] 2\n\n\nLa longueur d’un vecteur vide (NULL) est zéro.\n\nlength(NULL)\n\n[1] 0"
  },
  {
    "objectID": "rappels/vecteurs.html#combiner-des-vecteurs",
    "href": "rappels/vecteurs.html#combiner-des-vecteurs",
    "title": "1  Vecteurs",
    "section": "\n1.4 Combiner des vecteurs",
    "text": "1.4 Combiner des vecteurs\nPour combiner des vecteurs, rien de plus simple. Il suffit d’utiliser c() ! Les valeurs des différents vecteurs seront mises bout à bout pour créer un unique vecteur.\n\nx <- c(2, 1, 3, 4)\nlength(x)\n\n[1] 4\n\ny <- c(9, 1, 2, 6, 3, 0)\nlength(y)\n\n[1] 6\n\nz <- c(x, y)\nz\n\n [1] 2 1 3 4 9 1 2 6 3 0\n\nlength(z)\n\n[1] 10"
  },
  {
    "objectID": "rappels/vecteurs.html#vecteurs-nommés",
    "href": "rappels/vecteurs.html#vecteurs-nommés",
    "title": "1  Vecteurs",
    "section": "\n1.5 Vecteurs nommés",
    "text": "1.5 Vecteurs nommés\nLes différentes valeurs d’un vecteur peuvent être nommées. Une première manière de nommer les éléments d’un vecteur est de le faire à sa création :\n\nsexe <- c(Michel = \"h\", Anne = \"f\", Dominique = NA, Jean = \"h\", Claude = NA, Marie = \"f\")\n\nLorsqu’on affiche le vecteur, la présentation change quelque peu.\n\nsexe\n\n   Michel      Anne Dominique      Jean    Claude     Marie \n      \"h\"       \"f\"        NA       \"h\"        NA       \"f\" \n\n\nLa liste des noms s’obtient avec names().\n\nnames(sexe)\n\n[1] \"Michel\"    \"Anne\"      \"Dominique\" \"Jean\"      \"Claude\"    \"Marie\"    \n\n\nPour ajouter ou modifier les noms d’un vecteur, on doit attribuer un nouveau vecteur de noms :\n\nnames(sexe) <- c(\"Michael\", \"Anna\", \"Dom\", \"John\", \"Alex\", \"Mary\")\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\n\nPour supprimer tous les noms, il y a la fonction unname() :\n\nanonyme <- unname(sexe)\nanonyme\n\n[1] \"h\" \"f\" NA  \"h\" NA  \"f\""
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-position",
    "href": "rappels/vecteurs.html#indexation-par-position",
    "title": "1  Vecteurs",
    "section": "\n1.6 Indexation par position",
    "text": "1.6 Indexation par position\nL’indexation est l’une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de R. Il s’agit d’opérations permettant de sélectionner des sous-ensembles de valeurs en fonction de différents critères. Il existe trois types d’indexation : (i) l’indexation par position, (ii) l’indexation par nom et (iii) l’indexation par condition. Le principe est toujours le même : on indique entre crochets5 ([]) ce qu’on souhaite garder ou non.5 Pour rappel, les crochets s’obtiennent sur un clavier français de type PC en appuyant sur la touche Alt Gr et la touche ( ou ).\nCommençons par l’indexation par position encore appelée indexation directe. Ce mode le plus simple d’indexation consiste à indiquer la position des éléments à conserver.\nReprenons notre vecteur taille :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\n\nSi on souhaite le premier élément du vecteur, on peut faire :\n\ntaille[1]\n\n[1] 1.88\n\n\nSi on souhaite les trois premiers éléments ou les éléments 2, 5 et 6 :\n\ntaille[1:3]\n\n[1] 1.88 1.65 1.92\n\ntaille[c(2, 5, 6)]\n\n[1] 1.65   NA 1.72\n\n\nSi on veut le dernier élément :\n\ntaille[length(taille)]\n\n[1] 1.72\n\n\nIl est tout à fait possible de sélectionner les valeurs dans le désordre :\n\ntaille[c(5, 1, 4, 3)]\n\n[1]   NA 1.88 1.76 1.92\n\n\nDans le cadre de l’indexation par position, il est également possible de spécifier des nombres négatifs, auquel cas cela signifiera toutes les valeurs sauf celles-là. Par exemple :\n\ntaille[c(-1, -5)]\n\n[1] 1.65 1.92 1.76 1.72\n\n\nÀ noter, si on indique une position au-delà de la longueur du vecteur, R renverra NA. Par exemple :\n\ntaille[23:25]\n\n[1] NA NA NA"
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-nom",
    "href": "rappels/vecteurs.html#indexation-par-nom",
    "title": "1  Vecteurs",
    "section": "\n1.7 Indexation par nom",
    "text": "1.7 Indexation par nom\nLorsqu’un vecteur est nommé, il est dès lors possible d’accéder à ses valeurs à partir de leur nom. Il s’agit de l’indexation par nom.\n\nsexe[\"Anna\"]\n\nAnna \n \"f\" \n\nsexe[c(\"Mary\", \"Michael\", \"John\")]\n\n   Mary Michael    John \n    \"f\"     \"h\"     \"h\" \n\n\nPar contre il n’est pas possible d’utiliser l’opérateur - comme pour l’indexation directe. Pour exclure un élément en fonction de son nom, on doit utiliser une autre forme d’indexation, l’indexation par condition, expliquée dans la section suivante. On peut ainsi faire…\n\nsexe[names(sexe) != \"Dom\"]\n\n… pour sélectionner tous les éléments sauf celui qui s’appelle Dom."
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-condition",
    "href": "rappels/vecteurs.html#indexation-par-condition",
    "title": "1  Vecteurs",
    "section": "\n1.8 Indexation par condition",
    "text": "1.8 Indexation par condition\nL’indexation par condition consiste à fournir un vecteur logique indiquant si chaque élément doit être inclus (si TRUE) ou exclu (si FALSE). Par exemple :\n\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\nsexe[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n\nMichael    John \n    \"h\"     \"h\" \n\n\nÉcrire manuellement une telle condition n’est pas très pratique à l’usage. Mais supposons que nous ayons également à notre disposition les deux vecteurs suivants, également de longueur 6.\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\npoids <- c(80, 63, 75, 87, 82, 67)\n\nLe vecteur urbain est un vecteur logique. On peut directement l’utiliser pour avoir le sexe des enquêtés habitant en milieu urbain :\n\nsexe[urbain]\n\nMichael    Anna    Mary \n    \"h\"     \"f\"     \"f\" \n\n\nSupposons qu’on souhaite maintenant avoir la taille des individus pesant 80 kilogrammes ou plus. Nous pouvons effectuer une comparaison à l’aide des opérateurs de comparaison suivants :\n\n\nTable 1.2: Opérateurs de comparaison\n\nOpérateur de comparaison\nSignification\n\n\n\n==\négal à\n\n\n!=\ndifférent de\n\n\n>\nstrictement supérieur à\n\n\n<\nstrictement inférieur à\n\n\n>=\nsupérieur ou égal à\n\n\n<=\ninférieur ou égal à\n\n\n\n\nVoyons tout de suite un exemple :\n\npoids >= 80\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n\nQue s’est-il passé ? Nous avons fourni à R une condition et il nous a renvoyé un vecteur logique avec autant d’éléments qu’il y a d’observations et dont la valeur est TRUE si la condition est remplie et FALSE dans les autres cas. Nous pouvons alors utiliser ce vecteur logique pour obtenir la taille des participants pesant 80 kilogrammes ou plus :\n\ntaille[poids >= 80]\n\n[1] 1.88 1.76   NA\n\n\nOn peut combiner ou modifier des conditions à l’aide des opérateurs logiques habituels :\n\n\nTable 1.3: Opérateurs logiques\n\nOpérateur logique\nSignification\n\n\n\n&\net logique\n\n\n|\nou logique\n\n\n!\nnégation logique\n\n\n\n\nSupposons que je veuille identifier les personnes pesant 80 kilogrammes ou plus et vivant en milieu urbain :\n\npoids >= 80 & urbain\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nLes résultats sont différents si je souhaite isoler les personnes pesant 80 kilogrammes ou plus ou vivant milieu urbain :\n\npoids >= 80 | urbain\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\n\n\n\n\n\n\nComparaison et valeur manquante\n\n\n\nUne remarque importante : quand l’un des termes d’une condition comporte une valeur manquante (NA), le résultat de cette condition n’est pas toujours TRUE ou FALSE, il peut aussi être à son tour une valeur manquante.\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\ntaille > 1.8\n\n[1]  TRUE FALSE  TRUE FALSE    NA FALSE\n\n\nOn voit que le test NA > 1.8 ne renvoie ni vrai ni faux, mais NA.\nUne autre conséquence importante de ce comportement est qu’on ne peut pas utiliser l’opérateur l’expression == NA pour tester la présence de valeurs manquantes. On utilisera à la place la fonction ad hoc is.na() :\n\nis.na(taille > 1.8)\n\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE\n\n\nPour compliquer encore un peu le tout, lorsqu’on utilise une condition pour l’indexation, si la condition renvoie NA, R ne sélectionne pas l’élément mais retourne quand même la valeur NA. Ceci a donc des conséquences sur le résultat d’une indexation par comparaison.\nPar exemple si je cherche à connaître le poids des personnes mesurant 1,80 mètre ou plus :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\npoids\n\n[1] 80 63 75 87 82 67\n\npoids[taille > 1.8]\n\n[1] 80 75 NA\n\n\nLes éléments pour lesquels la taille n’est pas connue ont été transformés en NA, ce qui n’influera pas le calcul d’une moyenne. Par contre, lorsqu’on utilisera assignation et indexation ensemble, cela peut créer des problèmes. Il est donc préférable lorsqu’on a des valeurs manquantes de les exclure ainsi :\n\npoids[taille > 1.8 & !is.na(taille)]\n\n[1] 80 75"
  },
  {
    "objectID": "rappels/vecteurs.html#assignation-par-indexation",
    "href": "rappels/vecteurs.html#assignation-par-indexation",
    "title": "1  Vecteurs",
    "section": "\n1.9 Assignation par indexation",
    "text": "1.9 Assignation par indexation\nL’indexation peut être combinée avec l’assignation (opérateur <-) pour modifier seulement certaines parties d’un vecteur. Ceci fonctionne pour les différents types d’indexation évoqués précédemment.\n\nv <- 1:5\nv\n\n[1] 1 2 3 4 5\n\nv[1] <- 3\nv\n\n[1] 3 2 3 4 5\n\nsexe[\"Alex\"] <- \"non-binaire\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n          \"h\"           \"f\"            NA           \"h\" \"non-binaire\" \n         Mary \n          \"f\" \n\n\nEnfin on peut modifier plusieurs éléments d’un seul coup soit en fournissant un vecteur, soit en profitant du mécanisme de recyclage. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :\n\nsexe[c(1,3,4)] <- c(\"Homme\", \"Homme\", \"Homme\")\nsexe[c(1,3,4)] <- \"Homme\"\n\nL’assignation par indexation peut aussi être utilisée pour ajouter une ou plusieurs valeurs à un vecteur :\n\nlength(sexe)\n\n[1] 6\n\nsexe[7] <- \"f\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n      \"Homme\"           \"f\"       \"Homme\"       \"Homme\" \"non-binaire\" \n         Mary               \n          \"f\"           \"f\" \n\nlength(sexe)\n\n[1] 7"
  },
  {
    "objectID": "rappels/vecteurs.html#en-résumé",
    "href": "rappels/vecteurs.html#en-résumé",
    "title": "1  Vecteurs",
    "section": "\n1.10 En résumé",
    "text": "1.10 En résumé\n\nUn vecteur est un objet unidimensionnel contenant une liste de valeurs qui sont toutes du même type (entières, numériques, textuelles ou logiques).\nLa fonction class() permet de connaître le type du vecteur et la fonction length() sa longueur, c’est-à-dire son nombre d’éléments.\nLa fonction c() sert à créer et à combiner des vecteurs.\nLes valeurs manquantes sont représentées avec NA.\nUn vecteur peut être nommé, c’est-à-dire qu’un nom textuel a été associé à chaque élément. Cela peut se faire lors de sa création ou avec la fonction names().\nL’indexation consiste à extraire certains éléments d’un vecteur. Pour cela, on indique ce qu’on souhaite extraire entre crochets ([]) juste après le nom du vecteur. Le type d’indexation dépend du type d’information transmise.\nS’il s’agit de nombres entiers, c’est l’indexation par position : les nombres représentent la position dans le vecteur des éléments qu’on souhaite extraire. Un nombre négatif s’interprète comme tous les éléments sauf celui-là.\nSi on indique des chaînes de caractères, c’est l’indexation par nom : on indique le nom des éléments qu’on souhaite extraire. Cette forme d’indexation ne fonctionne que si le vecteur est nommé.\nSi on transmet des valeurs logiques, le plus souvent sous la forme d’une condition, c’est l’indexation par condition : TRUE indique les éléments à extraire et FALSE les éléments à exclure. Il faut être vigilant aux valeurs manquantes (NA) dans ce cas précis.\nEnfin, il est possible de ne modifier que certains éléments d’un vecteur en ayant recours à la fois à l’indexation ([]) et à l’assignation (<-)."
  },
  {
    "objectID": "rappels/vecteurs.html#webin-r",
    "href": "rappels/vecteurs.html#webin-r",
    "title": "1  Vecteurs",
    "section": "\n1.11 webin-R",
    "text": "1.11 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "rappels/listes.html",
    "href": "rappels/listes.html",
    "title": "2  Listes",
    "section": "",
    "text": "Par nature, les vecteurs ne peuvent contenir que des valeurs de même type (numérique, textuel ou logique). Or, on peut avoir besoin de représenter des objets plus complexes composés d’éléments disparates. C’est ce que permettent les listes."
  },
  {
    "objectID": "rappels/listes.html#propriétés-et-création",
    "href": "rappels/listes.html#propriétés-et-création",
    "title": "2  Listes",
    "section": "\n2.1 Propriétés et création",
    "text": "2.1 Propriétés et création\nUne liste se crée tout simplement avec la fonction list() :\n\nl1 <- list(1:5, \"abc\")\nl1\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n\nUne liste est un ensemble d’objets, quels qu’ils soient, chaque élément d’une liste pouvant avoir ses propres dimensions. Dans notre exemple précédent, nous avons créé une liste l1 composée de deux éléments : un vecteur d’entiers de longueur 5 et un vecteur textuel de longueur 1. La longueur d’une liste correspond aux nombres d’éléments qu’elle contient et s’obtient avec length() :\n\nlength(l1)\n\n[1] 2\n\n\nComme les vecteurs, une liste peut être nommée et les noms des éléments d’une liste sont accessibles avec names() :\n\nl2 <- list(\n  minuscules = letters, \n  majuscules = LETTERS, \n  mois = month.name\n)\nl2\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nlength(l2)\n\n[1] 3\n\nnames(l2)\n\n[1] \"minuscules\" \"majuscules\" \"mois\"      \n\n\nQue se passe-t-il maintenant si on effectue la commande suivante ?\n\nl <- list(l1, l2)\n\nÀ votre avis, quelle est la longueur de cette nouvelle liste l ? 5 ?\n\nlength(l)\n\n[1] 2\n\n\nEh bien non ! Elle est de longueur 2 car nous avons créé une liste composée de deux éléments qui sont eux-mêmes des listes. Cela est plus lisible si on fait appel à la fonction str() qui permet de visualiser la structure d’un objet.\n\nstr(l)\n\nList of 2\n $ :List of 2\n  ..$ : int [1:5] 1 2 3 4 5\n  ..$ : chr \"abc\"\n $ :List of 3\n  ..$ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n  ..$ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\nUne liste peut contenir tous types d’objets, y compris d’autres listes. Pour combiner les éléments d’une liste, il faut utiliser la fonction append() :\n\nl <- append(l1, l2)\nlength(l)\n\n[1] 5\n\nstr(l)\n\nList of 5\n $           : int [1:5] 1 2 3 4 5\n $           : chr \"abc\"\n $ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n $ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\n\n\n\n\n\n\nNote\n\n\n\nOn peut noter en passant qu’une liste peut tout à fait n’être que partiellement nommée."
  },
  {
    "objectID": "rappels/listes.html#indexation",
    "href": "rappels/listes.html#indexation",
    "title": "2  Listes",
    "section": "\n2.2 Indexation",
    "text": "2.2 Indexation\nLes crochets simples ([]) fonctionnent comme pour les vecteurs. On peut utiliser à la fois l’indexation par position, l’indexation par nom et l’indexation par condition.\n\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nl[c(1,3,4)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nl[c(\"majuscules\", \"minuscules\")]\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nl[c(TRUE, TRUE, FALSE, FALSE, TRUE)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMême si on extrait un seul élément, l’extraction obtenue avec les crochets simples renvoie toujours une liste, ici composée d’un seul élément :\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\n\nSupposons que je souhaite calculer la moyenne des valeurs du premier élément de ma liste. Essayons la commande suivante :\n\nmean(l[1])\n\nWarning in mean.default(l[1]): l'argument n'est ni numérique, ni logique :\nrenvoi de NA\n\n\n[1] NA\n\n\nNous obtenons un message d’erreur. En effet, R ne sait pas calculer une moyenne à partir d’une liste. Ce qu’il lui faut, c’est un vecteur de valeurs numériques. Autrement dit, ce que nous cherchons à obtenir c’est le contenu même du premier élément de notre liste et non une liste à un seul élément.\nC’est ici que les doubles crochets ([[]]) vont rentrer en jeu. Pour ces derniers, nous pourrons utiliser l’indexation par position ou l’indexation par nom, mais pas l’indexation par condition. De plus, le critère qu’on indiquera doit indiquer un et un seul élément de notre liste. Au lieu de renvoyer une liste à un élément, les doubles crochets vont renvoyer l’élément désigné.\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\nstr(l[[1]])\n\n int [1:5] 1 2 3 4 5\n\n\nMaintenant, nous pouvons calculer notre moyenne :\n\nmean(l[[1]])\n\n[1] 3\n\n\nNous pouvons aussi utiliser l’indexation par nom.\n\nl[[\"mois\"]]\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMais il faut avouer que cette écriture avec doubles crochets et guillemets est un peu lourde. Heureusement, un nouvel acteur entre en scène : le symbole dollar ($). C’est un raccourci des doubles crochets pour l’indexation par nom qu’on utilise ainsi :\n\nl$mois\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nLes écritures l$mois et l[[\"mois\"]] sont équivalentes. Attention ! Cela ne fonctionne que pour l’indexation par nom.\n\nl$1\n\n\nError: unexpected numeric constant in \"l$1\"\n\nL’assignation par indexation fonctionne également avec les doubles crochets ou le signe dollar :\n\nl[[2]] <- list(c(\"un\", \"vecteur\", \"textuel\"))\nl$mois <- c(\"Janvier\", \"Février\", \"Mars\")\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[[2]][[1]]\n[1] \"un\"      \"vecteur\" \"textuel\"\n\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n[1] \"Janvier\" \"Février\" \"Mars\""
  },
  {
    "objectID": "rappels/listes.html#en-résumé",
    "href": "rappels/listes.html#en-résumé",
    "title": "2  Listes",
    "section": "\n2.3 En résumé",
    "text": "2.3 En résumé\n\nLes listes sont des objets unidimensionnels pouvant contenir tout type d’objet, y compris d’autres listes.\nElles ont une longueur qu’on obtient avec length().\nOn crée une liste avec list() et on peut fusionner des listes avec append().\nTout comme les vecteurs, les listes peuvent être nommées et les noms des éléments s’obtiennent avec base::names().\nLes crochets simples ([]) permettent de sélectionner les éléments d’une liste, en utilisant l’indexation par position, l’indexation par nom ou l’indexation par condition. Cela renvoie toujours une autre liste.\nLes doubles crochets ([[]]) renvoient directement le contenu d’un élément de la liste qu’on aura sélectionné par position ou par nom.\nLe symbole $ est un raccourci pour facilement sélectionner un élément par son nom, liste$nom étant équivalent à liste[[\"nom\"]]."
  },
  {
    "objectID": "rappels/listes.html#webin-r",
    "href": "rappels/listes.html#webin-r",
    "title": "2  Listes",
    "section": "\n2.4 webin-R",
    "text": "2.4 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  }
]