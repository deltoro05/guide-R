[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "guide-R",
    "section": "",
    "text": "Site en construction\n\n\n\nLe présent site est en cours de construction et sera complété dans les prochains mois.\nEn attendant, nous vous conseillons de consulter le site analyse-R.\n\n\nCe guide porte sur l’analyse de données d’enquêtes avec le logiciel R, un logiciel libre de statitistiques et de traitement de données. Les exemples présentés ici relèvent principalement du champs des sciences sociales quantitatives et des sciences de santé. Ils peuvent néanmoins s’appliquer à d’autre champs disciplinaires. Cependant, comme tout ouvrage, ce guide ne peut être exhaustif.\nCe guide présente comment réaliser des analyses statistiques et diverses opérations courantes (comme la manipulation de données ou la production de graphiques) avec R. Il ne s’agit pas d’un cours de statistiques : les différents chapitres présupposent donc que vous avez déjà une connaissance des différentes techniques présentées. Si vous souhaitez des précisions théoriques / méthodologiques à propos d’un certain type d’analyses, nous vous conseillons d’utiliser votre moteur de recherche préféré. En effet, on trouve sur internet de très nombreux supports de cours (sans compter les nombreux ouvrages spécialisés disponibles en librairie).\nDe même, il ne s’agit pas d’une introduction ou d’un guide pour les utilisatrices et utilisateurs débutant·es. Si vous découvrez R, nous vous conseillons la lecture de l’Introduction à R et au tidyverse de Julien Barnier (https://juba.github.io/tidyverse/). Vous pouvez également lire les chapitres introductifs d’analyse-R : Introduction à l’analyse d’enquêtes avec R et RStudio (https://larmarange.github.io/analyse-R/). Néanmoins, quelques rappels sur les bases du langage sont fournis dans la section Rappels. Une bonne compréhension des bases du langage, bien qu’un peu ardue de prime abord, permet de comprendre le sens des commandes qu’on utilise et de pleinement exploiter la puissance que R offre en matière de manipulation de données.\nR disposent de nombreuses extensions ou packages (plus de 16 000) et il existe souvent plusieurs manières de procéder pour arriver au même résultat. En particulier, en matière de manipulation de données, on oppose1 souvent base R qui repose sur les fonctions disponibles en standard dans R, la majorité étant fournies dans les packages {base}, {utils} ou encore {stats}, qui sont toujours chargés par défaut, et le tidyverse qui est une collection de packages comprenant, entre autres, dplyr, tibble, tidyr, forcats ou encore ggplot2. Il y a un débat ouvert, parfois passionné, sur le fait de privilégier l’une ou l’autre approche, et les avantages et inconvénients de chacune dépendent de nombreux facteurs, comme la lisibilité du code ou bien les performances en temps de calcul. Dans ce guide, nous avons adopté un point de vue pragmatique et utiliserons, le plus souvent mais pas exclusivement, les fonctions du tidyverse, de même que nous avons privilégié d’autres packages, comme gtsummary ou questionr par exemple pour la statistique descriptive. Cela ne signifie pas, pour chaque point abordé, qu’il s’agit de l’unique manière de procéder. Dans certains cas, il s’agit simplement de préférences personnelles.1 Une comparaison des deux syntaxes est illustrée par une vignette dédiée de dplyr.\nBien qu’il en reprenne de nombreux contenus, ce guide ne se substitue pas au site analyse-R. Il s’agit plutôt d’une version complémentaire qui a vocation à être plus structurée et parfois plus sélective dans les contenus présentés.\nEn complément, on pourra également se référer aux webin-R, une série de vidéos avec partage d’écran, librement accessibles sur Youtube : https://www.youtube.com/c/webinR.\nCette version du guide a utilisé R version 4.2.1 (2022-06-23 ucrt). Ce document est généré avec quarto et le code source est disponible sur GitHub. Pour toute suggestion ou correction, vous pouvez ouvrir un ticket GitHub. Pour d’autres questions, vous pouvez utiliser les forums de discussion disponibles en bas de chaque page sur la version web du guide. Ce document est régulièrement mis à jour. La dernière version est consultable sur https://larmarange.github.io/guide-R/."
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "guide-R",
    "section": "Remerciements",
    "text": "Remerciements\nCe document a bénéficié de différents apports provenant notamment de l’Introduction à R et de l’Introduction à R et au tidyverse de Julien Barnier et d’analyse-R : introduction à l’analyse d’enquêtes avec R et RStudio.\nMerci donc à Julien Barnier, Julien Biaudet, François Briatte, Milan Bouchet-Valat, Ewen Gallic, Frédérique Giraud, Joël Gombin, Mayeul Kauffmann, Christophe Lalanne & Nicolas Robette."
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "guide-R",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International."
  },
  {
    "objectID": "rappels/packages.html",
    "href": "rappels/packages.html",
    "title": "1  Packages",
    "section": "",
    "text": "L’installation par défaut du logiciel R contient le cœur du programme ainsi qu’un ensemble de fonctions de base fournissant un grand nombre d’outils de traitement de données et d’analyse statistiques.\nR étant un logiciel libre, il bénéficie d’une forte communauté d’utilisateurs qui peuvent librement contribuer au développement du logiciel en lui ajoutant des fonctionnalités supplémentaires. Ces contributions prennent la forme d’extensions (packages en anglais) pouvant être installées par l’utilisateur et fournissant alors diverses fonctionnalités supplémentaires.\nIl existe un très grand nombre d’extensions (plus de 16 000 à ce jour), qui sont diffusées par un réseau baptisé CRAN (Comprehensive R Archive Network).\nLa liste de toutes les extensions disponibles sur CRAN est disponible ici : http://cran.r-project.org/web/packages/.\nPour faciliter un peu le repérage des extensions, il existe un ensemble de regroupements thématiques (économétrie, finance, génétique, données spatiales…) baptisés Task views : http://cran.r-project.org/web/views/.\nOn y trouve notamment une Task view dédiée aux sciences sociales, listant de nombreuses extensions potentiellement utiles pour les analyses statistiques dans ce champ disciplinaire : http://cran.r-project.org/web/views/SocialSciences.html.\nOn peut aussi citer le site Awesome R (https://github.com/qinwf/awesome-R) qui fournit une liste d’extensions choisies et triées par thématique."
  },
  {
    "objectID": "rappels/packages.html#installation-cran",
    "href": "rappels/packages.html#installation-cran",
    "title": "1  Packages",
    "section": "\n1.1 Installation (CRAN)",
    "text": "1.1 Installation (CRAN)\nL’installation d’une extension se fait par la fonction install.packages(), à qui on fournit le nom de l’extension. Par exemple, si on souhaite installer l’extension gtsummary :\n\ninstall.packages(\"gtsummary\")\n\nSous RStudio, on pourra également cliquer sur Install dans l’onglet Packages du quadrant inférieur droit.\nAlternativement, on pourra avoir recours au package remotes et à sa fonction remotes::install_cran() :\n\nremotes::install_cran(\"gtsummary\")\n\n\n\n\n\n\n\nNote\n\n\n\nLe package remotes n’est pas disponible par défaut sous R et devra donc être installé classiquement avec install.packages(\"remotes\"). À la différence de install.packages(), remotes::install_cran() vérifie si le package est déjà installé et, si oui, si la version installée est déjà la dernière version, avant de procéder à une installation complète si et seulement si cela est nécessaire."
  },
  {
    "objectID": "rappels/packages.html#chargement",
    "href": "rappels/packages.html#chargement",
    "title": "1  Packages",
    "section": "\n1.2 Chargement",
    "text": "1.2 Chargement\nUne fois un package installé (c’est-à-dire que ses fichiers ont eté téléchargés et copiés sur votre ordinateur), ses fonctions et objets ne sont pas directement accessibles. Pour pouvoir les utiliser, il faut, à chaque session de travail, charger le package en mémoire avec la fonction library() ou la fonction require() :\n\nlibrary(gtsummary)\n\nÀ partir de là, on peut utiliser les fonctions de l’extension, consulter leur page d’aide en ligne, accéder aux jeux de données qu’elle contient, etc.\nAlternativement, pour accéder à un objet ou une fonction d’un package sans avoir à le charger en mémoire, on pourra avoir recours à l’opérateur ::. Ainsi, l’écriture p::f() signifie la fonction f() du package p. Cette écriture sera notamment utilisée tout au long de ce guide pour indiquer à quel package appartient telle fonction : remotes::install_cran() indique que la fonction install_cran() provient du packages remotes.\n\n\n\n\n\n\nImportant\n\n\n\nIl est important de bien comprendre la différence entre install.packages() et library(). La première va chercher un package sur internet et l’installe en local sur le disque dur de l’ordinateur. On n’a besoin d’effectuer cette opération qu’une seule fois. La seconde lit les informations de l’extension sur le disque dur et les met à disposition de R. On a besoin de l’exécuter à chaque début de session ou de script."
  },
  {
    "objectID": "rappels/packages.html#mise-à-jour",
    "href": "rappels/packages.html#mise-à-jour",
    "title": "1  Packages",
    "section": "\n1.3 Mise à jour",
    "text": "1.3 Mise à jour\nPour mettre à jour l’ensemble des pacakges installés, il suffit d’exécuter la fonction update.packages() :\n\nupdate.packages()\n\nSous RStudio, on pourra alternativement cliquer sur Update dans l’onglet Packages du quadrant inférieur droit.\nSi on souhaite désinstaller une extension précédemment installée, on peut utiliser la fonction remove.packages() :\n\nremove.packages(\"gtsummary\")\n\n\n\n\n\n\n\nInstaller / Mettre à jour les packages utilisés par un projet\n\n\n\nAprès une mise à jour majeure de R, il est souvent nécessaire de réinstaller tous les packages utilisés. De même, on peut parfois souhaiter mettre à jour uniquement les packages utilisés par un projet donné sans avoir à mettre à jour tous les autres packages présents sur son PC.\nUne astuce consiste à avoir recours à la fonction renv::dependencies() qui examine le code du projet courant pour identifier les packages utilisés, puis à passer cette liste de packages à remotes::install_cran() qui installera les packages manquants ou pour lesquels une mise à jour est disponible.\nIl vous suffit d’exécuter la commande ci-dessous :\n\nrenv::dependencies() |> \n  purrr::pluck(\"Package\") |> \n  remotes::install_cran()"
  },
  {
    "objectID": "rappels/packages.html#installation-depuis-github",
    "href": "rappels/packages.html#installation-depuis-github",
    "title": "1  Packages",
    "section": "\n1.4 Installation depuis GitHub",
    "text": "1.4 Installation depuis GitHub\nCertains packages ne sont pas disponibles sur CRAN mais seulement sur GitHub, une plateforme de développement informatique. Il s’agit le plus souvent de packages qui ne sont pas encore suffisament matures pour être diffusés sur CRAN (sachant que des vérifications strictes sont effectués avant qu’un package ne soit référencés sur CRAN).\nDans d’autres cas de figure, la dernière version stable d’un package est disponible sur CRAN tandis que la version en cours de développement est, elle, disponible sur GitHub. Il fuat être vigilant avec les versions de développement. Parfois, elle corrige un bug ou introduit une nouvelle fonctionnalité qui n’est pas encore dans la version stable. Mais les versions de développement peuvent aussi contenir de nouveaux bugs ou des fonctionnalités instables.\n\n\n\n\n\n\nSous Windows\n\n\n\nPour les utilisatrices et utilisateurs sous Windows, il faut être conscient que le code source d’un package doit être compilé afin de pouvoir être utilisé. CRAN fournit une version des packages déjà compilée pour Windows ce qui facilite l’installation.\nPar contre, lorsque l’on installe un package depuis GitHub, R ne récupère que le code source et il est donc nécessaire de compiler localement le package. Pour cela, il est nécessaire que soit installé sur le PC un outil complémentaire appelé RTools. Il est téléchargeable à l’adresse https://cran.r-project.org/bin/windows/Rtools/.\n\n\nLe code source du package labelled est disponible sur GitHub à l’adresse https://github.com/larmarange/labelled. Pour installer la version de développement de labelled,on aura recours à la fonction remotes::install_github() à laquelle on passera la partie située à droite de https://github.com/ dans l’URL du package, à savoir :\n\nremotes::install_github(\"larmarange/labelled\")"
  },
  {
    "objectID": "rappels/packages.html#le-tidyverse",
    "href": "rappels/packages.html#le-tidyverse",
    "title": "1  Packages",
    "section": "\n1.5 Le tidyverse",
    "text": "1.5 Le tidyverse\nLe terme tidyverse est une contraction de tidy (qu’on pourrait traduire par bien rangé) et de universe. Il s’agit en fait d’une collection de packages conçus pour travailler ensemble et basés sur une philosophie commune.\nIls abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive) :\n\nvisualisation (ggplot2)\nmanipulation des tableaux de données (dplyr, tidyr)\nimport/export de données (readr, readxl, haven)\nmanipulation de variables (forcats, stringr, lubridate)\nprogrammation (purrr, magrittr, glue)\n\nUn des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham, qui travaille désormais pour RStudio.\ntidyverse est également le nom d’une extension générique qui permets d’installer en une seule commande l’ensemble des packages constituant le tidyverse :\n\ninstall.packages(\"tidyverse\")\n\nLorsque l’on charge le package tidyverse avec library(), cela charge également en mémoire les principaux packages du tidyverse1.1 Si on a besoin d’un autre package du tidyverse comme lubridate, il faudra donc le charger individuellement.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.3.6      ✔ purrr   0.3.4 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.2      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\n\nFigure 1.1: Packages chargés avec library(tidyverse)"
  },
  {
    "objectID": "rappels/vecteurs.html",
    "href": "rappels/vecteurs.html",
    "title": "2  Vecteurs",
    "section": "",
    "text": "Les vecteurs sont l’objet de base de R et correspondent à une liste de valeurs. Leurs propriétés fondamentales sont :"
  },
  {
    "objectID": "rappels/vecteurs.html#types-et-classes",
    "href": "rappels/vecteurs.html#types-et-classes",
    "title": "2  Vecteurs",
    "section": "\n2.1 Types et classes",
    "text": "2.1 Types et classes\nDans R, il existe plusieurs types fondamentaux de vecteurs et, en particulier, :\n\nles nombres réels (c’est-à-dire les nombres décimaux1), par exemple 5.23 ;\nles nombres entiers, que l’on saisi en ajoutant le suffixe L2, par exemple 4L ;\nles chaînes de caractères (qui correspondent à du texte), que l’on saisit avec des guillemets doubles (\") ou simples ('), par exemple \"abc\" ;\nles valeurs logiques ou valeurs booléennes, à savoir vrai ou faux, que l’on représente avec les mots TRUE et FALSE (en majuscules3).\n\n1 Pour rappel, R étant anglophone, le caractère utilisé pour indiqué les chiffres après la virgule est le point (.).2 R utilise 32 bits pour représenter des nombres entiers, ce qui correspond en informatique à des entiers longs ou long integers en anglais, d’où la lettre L utilisée pour indiquer un nombre entier.3 On peut également utiliser les raccourcis T et F. Cependant, pour une meilleure lisibilité du code, il est préférable d’utiliser les versions longues TRUE et FALSE.En plus de ces types de base, il existe de nombreux autres types de vecteurs utilisés pour représenter toutes sortes de données, comme les facteurs (voir Chapitre 5) ou les dates (voir Chapitre 6).\nLa fonction class() renvoie la nature d’un vecteur tandis que la fonction typeof() indique la manière dont un vecteur est stocké de manière interne par R.\n\n\nTable 2.1: Le type et la classe des principaux types de vecteurs\n\n\n\n\n\n\nx\nclass(x)\ntypeof(x)\n\n\n\n3L\ninteger\ninteger\n\n\n5.3\nnumeric\ndouble\n\n\nTRUE\nlogical\nlogical\n\n\n\"abc\"\ncharacter\ncharacter\n\n\nfactor(\"a\")\nfactor\ninteger\n\n\nas.Date(\"2020-01-01\")\nDate\ndouble\n\n\n\n\n\n\n\n\n\n\nAstuce\n\n\n\nPour un vecteur numérique, le type est \"double\" car R utilise une double précision pour stocker informatiquement les nombres réels.\nEn interne, les facteurs sont représentés par un nombre entier auquel est attaché une étiquette, c’est pourquoi typeof() renvoie \"integer\".\nQuand aux dates, elles sont stockées en interne sous la forme d’un nombre réel représentant le nombre de jours depuis le 1er janvier 1970, d’où le fait que typeof() renvoie \"double\"."
  },
  {
    "objectID": "rappels/vecteurs.html#création-dun-vecteur",
    "href": "rappels/vecteurs.html#création-dun-vecteur",
    "title": "2  Vecteurs",
    "section": "\n2.2 Création d’un vecteur",
    "text": "2.2 Création d’un vecteur\nPour créer un vecteur, on utilisera la fonction c() en lui passant la liste des valeurs à combiner4.4 La lettre c est un raccourci du mot anglais combine, puisque cette fonction permet de combiner des valeurs individuelles dans un vecteur unique.\n\ntaille <- c(1.88, 1.65, 1.92, 1.76, NA, 1.72)\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\nsexe <- c(\"h\", \"f\", \"h\", \"f\", \"f\", \"f\")\nsexe\n\n[1] \"h\" \"f\" \"h\" \"f\" \"f\" \"f\"\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\nurbain\n\n[1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\n\n\nNous l’avons vu, toutes les valeurs d’un vecteur doivent obligatoirement être du même type. Dès lors, si on essaie de combiner des valeurs de différents types, R essaiera de les convertir au mieux. Par exemple :\n\nx <- c(2L, 3.14, \"a\")\nx\n\n[1] \"2\"    \"3.14\" \"a\"   \n\nclass(x)\n\n[1] \"character\"\n\n\nDans le cas présent, toutes les valeurs ont été converties en chaînes de caractères.\nDans certaines situations, on peut avoir besoin de créer un vecteur d’une certaine longueur mais dont toutes les valeurs sont identiques. Cela se réalise facilement avec rep() à qui on indiquera la valeur à répéter puis le nombre de répétitions :\n\nrep(2, 10)\n\n [1] 2 2 2 2 2 2 2 2 2 2\n\n\nOn peut aussi lui indiquer plusieurs valeurs qui seront alors répétées en boucle :\n\nrep(c(\"a\", \"b\"), 3)\n\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n\n\nDans d’autres situations, on peut avoir besoin de créer un vecteur contenant une suite de valeurs, ce qui se réalise aisément avec seq() à qui on précisera les arguments from (point de départ), to (point d’arrivée) et by (pas). Quelques exemples valent mieux qu’un long discours :\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(5, 17, by = 2)\n\n[1]  5  7  9 11 13 15 17\n\nseq(10, 0)\n\n [1] 10  9  8  7  6  5  4  3  2  1  0\n\nseq(100, 10, by = -10)\n\n [1] 100  90  80  70  60  50  40  30  20  10\n\nseq(1.23, 5.67, by = 0.33) \n\n [1] 1.23 1.56 1.89 2.22 2.55 2.88 3.21 3.54 3.87 4.20 4.53 4.86 5.19 5.52\n\n\nL’opérateur : est un raccourci de la fonction seq() pour créer une suite de nombres entiers. Il s’utilise ainsi :\n\n1:5\n\n[1] 1 2 3 4 5\n\n24:32\n\n[1] 24 25 26 27 28 29 30 31 32\n\n55:43\n\n [1] 55 54 53 52 51 50 49 48 47 46 45 44 43"
  },
  {
    "objectID": "rappels/vecteurs.html#longueur-dun-vecteur",
    "href": "rappels/vecteurs.html#longueur-dun-vecteur",
    "title": "2  Vecteurs",
    "section": "\n2.3 Longueur d’un vecteur",
    "text": "2.3 Longueur d’un vecteur\nLa longueur d’un vecteur correspond au nombre de valeurs qui le composent. Elle s’obtient avec length() :\n\nlength(taille)\n\n[1] 4\n\nlength(c(\"a\", \"b\"))\n\n[1] 2\n\n\nLa longueur d’un vecteur vide (NULL) est zéro.\n\nlength(NULL)\n\n[1] 0"
  },
  {
    "objectID": "rappels/vecteurs.html#combiner-des-vecteurs",
    "href": "rappels/vecteurs.html#combiner-des-vecteurs",
    "title": "2  Vecteurs",
    "section": "\n2.4 Combiner des vecteurs",
    "text": "2.4 Combiner des vecteurs\nPour combiner des vecteurs, rien de plus simple. Il suffit d’utiliser c() ! Les valeurs des différents vecteurs seront mises bout à bout pour créer un unique vecteur.\n\nx <- c(2, 1, 3, 4)\nlength(x)\n\n[1] 4\n\ny <- c(9, 1, 2, 6, 3, 0)\nlength(y)\n\n[1] 6\n\nz <- c(x, y)\nz\n\n [1] 2 1 3 4 9 1 2 6 3 0\n\nlength(z)\n\n[1] 10"
  },
  {
    "objectID": "rappels/vecteurs.html#vecteurs-nommés",
    "href": "rappels/vecteurs.html#vecteurs-nommés",
    "title": "2  Vecteurs",
    "section": "\n2.5 Vecteurs nommés",
    "text": "2.5 Vecteurs nommés\nLes différentes valeurs d’un vecteur peuvent être nommées. Une première manière de nommer les éléments d’un vecteur est de le faire à sa création :\n\nsexe <- c(\n  Michel = \"h\", Anne = \"f\", \n  Dominique = NA, Jean = \"h\", \n  Claude = NA, Marie = \"f\"\n)\n\nLorsqu’on affiche le vecteur, la présentation change quelque peu.\n\nsexe\n\n   Michel      Anne Dominique      Jean    Claude     Marie \n      \"h\"       \"f\"        NA       \"h\"        NA       \"f\" \n\n\nLa liste des noms s’obtient avec names().\n\nnames(sexe)\n\n[1] \"Michel\"    \"Anne\"      \"Dominique\" \"Jean\"      \"Claude\"    \"Marie\"    \n\n\nPour ajouter ou modifier les noms d’un vecteur, on doit attribuer un nouveau vecteur de noms :\n\nnames(sexe) <- c(\"Michael\", \"Anna\", \"Dom\", \"John\", \"Alex\", \"Mary\")\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\n\nPour supprimer tous les noms, il y a la fonction unname() :\n\nanonyme <- unname(sexe)\nanonyme\n\n[1] \"h\" \"f\" NA  \"h\" NA  \"f\""
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-position",
    "href": "rappels/vecteurs.html#indexation-par-position",
    "title": "2  Vecteurs",
    "section": "\n2.6 Indexation par position",
    "text": "2.6 Indexation par position\nL’indexation est l’une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de R. Il s’agit d’opérations permettant de sélectionner des sous-ensembles de valeurs en fonction de différents critères. Il existe trois types d’indexation : (i) l’indexation par position, (ii) l’indexation par nom et (iii) l’indexation par condition. Le principe est toujours le même : on indique entre crochets5 ([]) ce qu’on souhaite garder ou non.5 Pour rappel, les crochets s’obtiennent sur un clavier français de type PC en appuyant sur la touche Alt Gr et la touche ( ou ).\nCommençons par l’indexation par position encore appelée indexation directe. Ce mode le plus simple d’indexation consiste à indiquer la position des éléments à conserver.\nReprenons notre vecteur taille :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\n\nSi on souhaite le premier élément du vecteur, on peut faire :\n\ntaille[1]\n\n[1] 1.88\n\n\nSi on souhaite les trois premiers éléments ou les éléments 2, 5 et 6 :\n\ntaille[1:3]\n\n[1] 1.88 1.65 1.92\n\ntaille[c(2, 5, 6)]\n\n[1] 1.65   NA 1.72\n\n\nSi on veut le dernier élément :\n\ntaille[length(taille)]\n\n[1] 1.72\n\n\nIl est tout à fait possible de sélectionner les valeurs dans le désordre :\n\ntaille[c(5, 1, 4, 3)]\n\n[1]   NA 1.88 1.76 1.92\n\n\nDans le cadre de l’indexation par position, il est également possible de spécifier des nombres négatifs, auquel cas cela signifiera toutes les valeurs sauf celles-là. Par exemple :\n\ntaille[c(-1, -5)]\n\n[1] 1.65 1.92 1.76 1.72\n\n\nÀ noter, si on indique une position au-delà de la longueur du vecteur, R renverra NA. Par exemple :\n\ntaille[23:25]\n\n[1] NA NA NA"
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-nom",
    "href": "rappels/vecteurs.html#indexation-par-nom",
    "title": "2  Vecteurs",
    "section": "\n2.7 Indexation par nom",
    "text": "2.7 Indexation par nom\nLorsqu’un vecteur est nommé, il est dès lors possible d’accéder à ses valeurs à partir de leur nom. Il s’agit de l’indexation par nom.\n\nsexe[\"Anna\"]\n\nAnna \n \"f\" \n\nsexe[c(\"Mary\", \"Michael\", \"John\")]\n\n   Mary Michael    John \n    \"f\"     \"h\"     \"h\" \n\n\nPar contre il n’est pas possible d’utiliser l’opérateur - comme pour l’indexation directe. Pour exclure un élément en fonction de son nom, on doit utiliser une autre forme d’indexation, l’indexation par condition, expliquée dans la section suivante. On peut ainsi faire…\n\nsexe[names(sexe) != \"Dom\"]\n\n… pour sélectionner tous les éléments sauf celui qui s’appelle Dom."
  },
  {
    "objectID": "rappels/vecteurs.html#indexation-par-condition",
    "href": "rappels/vecteurs.html#indexation-par-condition",
    "title": "2  Vecteurs",
    "section": "\n2.8 Indexation par condition",
    "text": "2.8 Indexation par condition\nL’indexation par condition consiste à fournir un vecteur logique indiquant si chaque élément doit être inclus (si TRUE) ou exclu (si FALSE). Par exemple :\n\nsexe\n\nMichael    Anna     Dom    John    Alex    Mary \n    \"h\"     \"f\"      NA     \"h\"      NA     \"f\" \n\nsexe[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE)]\n\nMichael    John \n    \"h\"     \"h\" \n\n\nÉcrire manuellement une telle condition n’est pas très pratique à l’usage. Mais supposons que nous ayons également à notre disposition les deux vecteurs suivants, également de longueur 6.\n\nurbain <- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE)\npoids <- c(80, 63, 75, 87, 82, 67)\n\nLe vecteur urbain est un vecteur logique. On peut directement l’utiliser pour avoir le sexe des enquêtés habitant en milieu urbain :\n\nsexe[urbain]\n\nMichael    Anna    Mary \n    \"h\"     \"f\"     \"f\" \n\n\nSupposons qu’on souhaite maintenant avoir la taille des individus pesant 80 kilogrammes ou plus. Nous pouvons effectuer une comparaison à l’aide des opérateurs de comparaison suivants :\n\n\nTable 2.2: Opérateurs de comparaison\n\nOpérateur de comparaison\nSignification\n\n\n\n==\négal à\n\n\n%in%\nappartient à\n\n\n!=\ndifférent de\n\n\n>\nstrictement supérieur à\n\n\n<\nstrictement inférieur à\n\n\n>=\nsupérieur ou égal à\n\n\n<=\ninférieur ou égal à\n\n\n\n\nVoyons tout de suite un exemple :\n\npoids >= 80\n\n[1]  TRUE FALSE FALSE  TRUE  TRUE FALSE\n\n\nQue s’est-il passé ? Nous avons fourni à R une condition et il nous a renvoyé un vecteur logique avec autant d’éléments qu’il y a d’observations et dont la valeur est TRUE si la condition est remplie et FALSE dans les autres cas. Nous pouvons alors utiliser ce vecteur logique pour obtenir la taille des participants pesant 80 kilogrammes ou plus :\n\ntaille[poids >= 80]\n\n[1] 1.88 1.76   NA\n\n\nOn peut combiner ou modifier des conditions à l’aide des opérateurs logiques habituels :\n\n\nTable 2.3: Opérateurs logiques\n\nOpérateur logique\nSignification\n\n\n\n&\net logique\n\n\n|\nou logique\n\n\n!\nnégation logique\n\n\n\n\nSupposons que je veuille identifier les personnes pesant 80 kilogrammes ou plus et vivant en milieu urbain :\n\npoids >= 80 & urbain\n\n[1]  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nLes résultats sont différents si je souhaite isoler les personnes pesant 80 kilogrammes ou plus ou vivant milieu urbain :\n\npoids >= 80 | urbain\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n\n\n\n\n\n\n\n\nComparaison et valeur manquante\n\n\n\nUne remarque importante : quand l’un des termes d’une condition comporte une valeur manquante (NA), le résultat de cette condition n’est pas toujours TRUE ou FALSE, il peut aussi être à son tour une valeur manquante.\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\ntaille > 1.8\n\n[1]  TRUE FALSE  TRUE FALSE    NA FALSE\n\n\nOn voit que le test NA > 1.8 ne renvoie ni vrai ni faux, mais NA.\nUne autre conséquence importante de ce comportement est qu’on ne peut pas utiliser l’opérateur l’expression == NA pour tester la présence de valeurs manquantes. On utilisera à la place la fonction ad hoc is.na() :\n\nis.na(taille > 1.8)\n\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE\n\n\nPour compliquer encore un peu le tout, lorsqu’on utilise une condition pour l’indexation, si la condition renvoie NA, R ne sélectionne pas l’élément mais retourne quand même la valeur NA. Ceci a donc des conséquences sur le résultat d’une indexation par comparaison.\nPar exemple si je cherche à connaître le poids des personnes mesurant 1,80 mètre ou plus :\n\ntaille\n\n[1] 1.88 1.65 1.92 1.76   NA 1.72\n\npoids\n\n[1] 80 63 75 87 82 67\n\npoids[taille > 1.8]\n\n[1] 80 75 NA\n\n\nLes éléments pour lesquels la taille n’est pas connue ont été transformés en NA, ce qui n’influera pas le calcul d’une moyenne. Par contre, lorsqu’on utilisera assignation et indexation ensemble, cela peut créer des problèmes. Il est donc préférable lorsqu’on a des valeurs manquantes de les exclure ainsi :\n\npoids[taille > 1.8 & !is.na(taille)]\n\n[1] 80 75"
  },
  {
    "objectID": "rappels/vecteurs.html#assignation-par-indexation",
    "href": "rappels/vecteurs.html#assignation-par-indexation",
    "title": "2  Vecteurs",
    "section": "\n2.9 Assignation par indexation",
    "text": "2.9 Assignation par indexation\nL’indexation peut être combinée avec l’assignation (opérateur <-) pour modifier seulement certaines parties d’un vecteur. Ceci fonctionne pour les différents types d’indexation évoqués précédemment.\n\nv <- 1:5\nv\n\n[1] 1 2 3 4 5\n\nv[1] <- 3\nv\n\n[1] 3 2 3 4 5\n\nsexe[\"Alex\"] <- \"non-binaire\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n          \"h\"           \"f\"            NA           \"h\" \"non-binaire\" \n         Mary \n          \"f\" \n\n\nEnfin on peut modifier plusieurs éléments d’un seul coup soit en fournissant un vecteur, soit en profitant du mécanisme de recyclage. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :\n\nsexe[c(1,3,4)] <- c(\"Homme\", \"Homme\", \"Homme\")\nsexe[c(1,3,4)] <- \"Homme\"\n\nL’assignation par indexation peut aussi être utilisée pour ajouter une ou plusieurs valeurs à un vecteur :\n\nlength(sexe)\n\n[1] 6\n\nsexe[7] <- \"f\"\nsexe\n\n      Michael          Anna           Dom          John          Alex \n      \"Homme\"           \"f\"       \"Homme\"       \"Homme\" \"non-binaire\" \n         Mary               \n          \"f\"           \"f\" \n\nlength(sexe)\n\n[1] 7"
  },
  {
    "objectID": "rappels/vecteurs.html#en-résumé",
    "href": "rappels/vecteurs.html#en-résumé",
    "title": "2  Vecteurs",
    "section": "\n2.10 En résumé",
    "text": "2.10 En résumé\n\nUn vecteur est un objet unidimensionnel contenant une liste de valeurs qui sont toutes du même type (entières, numériques, textuelles ou logiques).\nLa fonction class() permet de connaître le type du vecteur et la fonction length() sa longueur, c’est-à-dire son nombre d’éléments.\nLa fonction c() sert à créer et à combiner des vecteurs.\nLes valeurs manquantes sont représentées avec NA.\nUn vecteur peut être nommé, c’est-à-dire qu’un nom textuel a été associé à chaque élément. Cela peut se faire lors de sa création ou avec la fonction names().\nL’indexation consiste à extraire certains éléments d’un vecteur. Pour cela, on indique ce qu’on souhaite extraire entre crochets ([]) juste après le nom du vecteur. Le type d’indexation dépend du type d’information transmise.\nS’il s’agit de nombres entiers, c’est l’indexation par position : les nombres représentent la position dans le vecteur des éléments qu’on souhaite extraire. Un nombre négatif s’interprète comme tous les éléments sauf celui-là.\nSi on indique des chaînes de caractères, c’est l’indexation par nom : on indique le nom des éléments qu’on souhaite extraire. Cette forme d’indexation ne fonctionne que si le vecteur est nommé.\nSi on transmet des valeurs logiques, le plus souvent sous la forme d’une condition, c’est l’indexation par condition : TRUE indique les éléments à extraire et FALSE les éléments à exclure. Il faut être vigilant aux valeurs manquantes (NA) dans ce cas précis.\nEnfin, il est possible de ne modifier que certains éléments d’un vecteur en ayant recours à la fois à l’indexation ([]) et à l’assignation (<-)."
  },
  {
    "objectID": "rappels/vecteurs.html#webin-r",
    "href": "rappels/vecteurs.html#webin-r",
    "title": "2  Vecteurs",
    "section": "\n2.11 webin-R",
    "text": "2.11 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "rappels/listes.html",
    "href": "rappels/listes.html",
    "title": "3  Listes",
    "section": "",
    "text": "Par nature, les vecteurs ne peuvent contenir que des valeurs de même type (numérique, textuel ou logique). Or, on peut avoir besoin de représenter des objets plus complexes composés d’éléments disparates. C’est ce que permettent les listes."
  },
  {
    "objectID": "rappels/listes.html#propriétés-et-création",
    "href": "rappels/listes.html#propriétés-et-création",
    "title": "3  Listes",
    "section": "\n3.1 Propriétés et création",
    "text": "3.1 Propriétés et création\nUne liste se crée tout simplement avec la fonction list() :\n\nl1 <- list(1:5, \"abc\")\nl1\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n\nUne liste est un ensemble d’objets, quels qu’ils soient, chaque élément d’une liste pouvant avoir ses propres dimensions. Dans notre exemple précédent, nous avons créé une liste l1 composée de deux éléments : un vecteur d’entiers de longueur 5 et un vecteur textuel de longueur 1. La longueur d’une liste correspond aux nombres d’éléments qu’elle contient et s’obtient avec length() :\n\nlength(l1)\n\n[1] 2\n\n\nComme les vecteurs, une liste peut être nommée et les noms des éléments d’une liste sont accessibles avec names() :\n\nl2 <- list(\n  minuscules = letters, \n  majuscules = LETTERS, \n  mois = month.name\n)\nl2\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nlength(l2)\n\n[1] 3\n\nnames(l2)\n\n[1] \"minuscules\" \"majuscules\" \"mois\"      \n\n\nQue se passe-t-il maintenant si on effectue la commande suivante ?\n\nl <- list(l1, l2)\n\nÀ votre avis, quelle est la longueur de cette nouvelle liste l ? 5 ?\n\nlength(l)\n\n[1] 2\n\n\nEh bien non ! Elle est de longueur 2 car nous avons créé une liste composée de deux éléments qui sont eux-mêmes des listes. Cela est plus lisible si on fait appel à la fonction str() qui permet de visualiser la structure d’un objet.\n\nstr(l)\n\nList of 2\n $ :List of 2\n  ..$ : int [1:5] 1 2 3 4 5\n  ..$ : chr \"abc\"\n $ :List of 3\n  ..$ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n  ..$ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n  ..$ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\nUne liste peut contenir tous types d’objets, y compris d’autres listes. Pour combiner les éléments d’une liste, il faut utiliser la fonction append() :\n\nl <- append(l1, l2)\nlength(l)\n\n[1] 5\n\nstr(l)\n\nList of 5\n $           : int [1:5] 1 2 3 4 5\n $           : chr \"abc\"\n $ minuscules: chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ majuscules: chr [1:26] \"A\" \"B\" \"C\" \"D\" ...\n $ mois      : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n\n\n\n\n\n\n\n\nNote\n\n\n\nOn peut noter en passant qu’une liste peut tout à fait n’être que partiellement nommée."
  },
  {
    "objectID": "rappels/listes.html#indexation",
    "href": "rappels/listes.html#indexation",
    "title": "3  Listes",
    "section": "\n3.2 Indexation",
    "text": "3.2 Indexation\nLes crochets simples ([]) fonctionnent comme pour les vecteurs. On peut utiliser à la fois l’indexation par position, l’indexation par nom et l’indexation par condition.\n\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\nl[c(1,3,4)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\nl[c(\"majuscules\", \"minuscules\")]\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nl[c(TRUE, TRUE, FALSE, FALSE, TRUE)]\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"abc\"\n\n$mois\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMême si on extrait un seul élément, l’extraction obtenue avec les crochets simples renvoie toujours une liste, ici composée d’un seul élément :\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\n\nSupposons que je souhaite calculer la moyenne des valeurs du premier élément de ma liste. Essayons la commande suivante :\n\nmean(l[1])\n\nWarning in mean.default(l[1]): l'argument n'est ni numérique, ni logique :\nrenvoi de NA\n\n\n[1] NA\n\n\nNous obtenons un message d’erreur. En effet, R ne sait pas calculer une moyenne à partir d’une liste. Ce qu’il lui faut, c’est un vecteur de valeurs numériques. Autrement dit, ce que nous cherchons à obtenir c’est le contenu même du premier élément de notre liste et non une liste à un seul élément.\nC’est ici que les doubles crochets ([[]]) vont rentrer en jeu. Pour ces derniers, nous pourrons utiliser l’indexation par position ou l’indexation par nom, mais pas l’indexation par condition. De plus, le critère qu’on indiquera doit indiquer un et un seul élément de notre liste. Au lieu de renvoyer une liste à un élément, les doubles crochets vont renvoyer l’élément désigné.\n\nstr(l[1])\n\nList of 1\n $ : int [1:5] 1 2 3 4 5\n\nstr(l[[1]])\n\n int [1:5] 1 2 3 4 5\n\n\nMaintenant, nous pouvons calculer notre moyenne :\n\nmean(l[[1]])\n\n[1] 3\n\n\nNous pouvons aussi utiliser l’indexation par nom.\n\nl[[\"mois\"]]\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nMais il faut avouer que cette écriture avec doubles crochets et guillemets est un peu lourde. Heureusement, un nouvel acteur entre en scène : le symbole dollar ($). C’est un raccourci des doubles crochets pour l’indexation par nom qu’on utilise ainsi :\n\nl$mois\n\n [1] \"January\"   \"February\"  \"March\"     \"April\"     \"May\"       \"June\"     \n [7] \"July\"      \"August\"    \"September\" \"October\"   \"November\"  \"December\" \n\n\nLes écritures l$mois et l[[\"mois\"]] sont équivalentes. Attention ! Cela ne fonctionne que pour l’indexation par nom.\n\nl$1\n\n\nError: unexpected numeric constant in \"l$1\"\n\nL’assignation par indexation fonctionne également avec les doubles crochets ou le signe dollar :\n\nl[[2]] <- list(c(\"un\", \"vecteur\", \"textuel\"))\nl$mois <- c(\"Janvier\", \"Février\", \"Mars\")\nl\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[[2]][[1]]\n[1] \"un\"      \"vecteur\" \"textuel\"\n\n\n$minuscules\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$majuscules\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n$mois\n[1] \"Janvier\" \"Février\" \"Mars\""
  },
  {
    "objectID": "rappels/listes.html#en-résumé",
    "href": "rappels/listes.html#en-résumé",
    "title": "3  Listes",
    "section": "\n3.3 En résumé",
    "text": "3.3 En résumé\n\nLes listes sont des objets unidimensionnels pouvant contenir tout type d’objet, y compris d’autres listes.\nElles ont une longueur qu’on obtient avec length().\nOn crée une liste avec list() et on peut fusionner des listes avec append().\nTout comme les vecteurs, les listes peuvent être nommées et les noms des éléments s’obtiennent avec base::names().\nLes crochets simples ([]) permettent de sélectionner les éléments d’une liste, en utilisant l’indexation par position, l’indexation par nom ou l’indexation par condition. Cela renvoie toujours une autre liste.\nLes doubles crochets ([[]]) renvoient directement le contenu d’un élément de la liste qu’on aura sélectionné par position ou par nom.\nLe symbole $ est un raccourci pour facilement sélectionner un élément par son nom, liste$nom étant équivalent à liste[[\"nom\"]]."
  },
  {
    "objectID": "rappels/listes.html#webin-r",
    "href": "rappels/listes.html#webin-r",
    "title": "3  Listes",
    "section": "\n3.4 webin-R",
    "text": "3.4 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  },
  {
    "objectID": "rappels/tableaux_donnees.html",
    "href": "rappels/tableaux_donnees.html",
    "title": "4  Tableaux de données",
    "section": "",
    "text": "Les tableaux de données, ou data frame en anglais, est un type d’objets essentiel pour les données d’enquêtes."
  },
  {
    "objectID": "rappels/tableaux_donnees.html#propriétés-et-création",
    "href": "rappels/tableaux_donnees.html#propriétés-et-création",
    "title": "4  Tableaux de données",
    "section": "\n4.1 Propriétés et création",
    "text": "4.1 Propriétés et création\nDans R, les tableaux de données sont tout simplement des listes (voir Chapitre 3) avec quelques propriétés spécifiques :\n\nles tableaux de données ne peuvent contenir que des vecteurs ;\ntous les vecteurs d’un tableau de données ont la même longueur ;\ntous les éléments d’un tableau de données sont nommés et ont chacun un nom unique.\n\nDès lors, un tableau de données correspond aux fichiers de données qu’on a l’habitude de manipuler dans d’autres logiciels de statistiques comme SPSS ou Stata. Les variables sont organisées en colonnes et les observations en lignes.\nOn peut créer un tableau de données avec la fonction data.frame() :\n\ndf <- data.frame(\n  sexe =  c(\"f\", \"f\", \"h\", \"h\"), \n  age = c(52, 31, 29, 35), \n  blond = c(FALSE, TRUE, TRUE, FALSE)\n)\ndf\n\n  sexe age blond\n1    f  52 FALSE\n2    f  31  TRUE\n3    h  29  TRUE\n4    h  35 FALSE\n\nstr(df)\n\n'data.frame':   4 obs. of  3 variables:\n $ sexe : chr  \"f\" \"f\" \"h\" \"h\"\n $ age  : num  52 31 29 35\n $ blond: logi  FALSE TRUE TRUE FALSE\n\n\nUn tableau de données étant une liste, la fonction length() renverra le nombre d’éléments de la liste, donc dans le cas présent le nombre de variables, et names() leurs noms :\n\nlength(df)\n\n[1] 3\n\nnames(df)\n\n[1] \"sexe\"  \"age\"   \"blond\"\n\n\nComme tous les éléments d’un tableau de données ont la même longueur, cet objet peut être vu comme bidimensionnel. Les fonctions nrow(), ncol() et dim() donnent respectivement le nombre de lignes, le nombre de colonnes et les dimensions de notre tableau.\n\nnrow(df)\n\n[1] 4\n\nncol(df)\n\n[1] 3\n\ndim(df)\n\n[1] 4 3\n\n\nDe plus, tout comme les colonnes ont un nom, il est aussi possible de nommer les lignes avec row.names() :\n\nrow.names(df) <- c(\"Anna\", \"Mary-Ann\", \"Michael\", \"John\")\ndf\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\nMichael     h  29  TRUE\nJohn        h  35 FALSE"
  },
  {
    "objectID": "rappels/tableaux_donnees.html#indexation",
    "href": "rappels/tableaux_donnees.html#indexation",
    "title": "4  Tableaux de données",
    "section": "\n4.2 Indexation",
    "text": "4.2 Indexation\nLes tableaux de données étant des listes, nous pouvons donc utiliser les crochets simples ([]), les crochets doubles ([[]]) et le symbole dollar ($) pour extraire des parties de notre tableau, de la même manière que pour n’importe quelle liste.\n\ndf[1]\n\n         sexe\nAnna        f\nMary-Ann    f\nMichael     h\nJohn        h\n\ndf[[1]]\n\n[1] \"f\" \"f\" \"h\" \"h\"\n\ndf$sexe\n\n[1] \"f\" \"f\" \"h\" \"h\"\n\n\nCependant, un tableau de données étant un objet bidimensionnel, il est également possible d’extraire des données sur deux dimensions, à savoir un premier critère portant sur les lignes et un second portant sur les colonnes. Pour cela, nous utiliserons les crochets simples ([]) en séparant nos deux critères par une virgule (,).\nUn premier exemple :\n\ndf\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\nMichael     h  29  TRUE\nJohn        h  35 FALSE\n\ndf[3, 2]\n\n[1] 29\n\n\nCette première commande indique que nous souhaitons la troisième ligne de la seconde colonne, autrement dit l’âge de Michael. Le même résultat peut être obtenu avec l’indexation par nom, l’indexation par condition, ou un mélange de tout ça.\n\ndf[\"Michael\", \"age\"]\n\n[1] 29\n\ndf[c(F, F, T, F), c(F, T, F)]\n\n[1] 29\n\ndf[3, \"age\"]\n\n[1] 29\n\ndf[\"Michael\", 2]\n\n[1] 29\n\n\nIl est également possible de préciser un seul critère. Par exemple, si je souhaite les deux premières observations, ou les variables sexe et blond :\n\ndf[1:2,]\n\n         sexe age blond\nAnna        f  52 FALSE\nMary-Ann    f  31  TRUE\n\ndf[,c(\"sexe\", \"blond\")]\n\n         sexe blond\nAnna        f FALSE\nMary-Ann    f  TRUE\nMichael     h  TRUE\nJohn        h FALSE\n\n\nIl a suffi de laisser un espace vide avant ou après la virgule.\n\n\n\n\n\n\nAvertissement\n\n\n\nATTENTION ! Il est cependant impératif de laisser la virgule pour indiquer à R qu’on souhaite effectuer une indexation à deux dimensions. Si on oublie la virgule, cela nous ramène au mode de fonctionnement des listes. Et le résultat n’est pas forcément le même :\n\ndf[2, ]\n\n         sexe age blond\nMary-Ann    f  31  TRUE\n\ndf[, 2]\n\n[1] 52 31 29 35\n\ndf[2]\n\n         age\nAnna      52\nMary-Ann  31\nMichael   29\nJohn      35\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAu passage, on pourra noter quelques subtilités sur le résultat renvoyé.\n\nstr(df[2, ])\n\n'data.frame':   1 obs. of  3 variables:\n $ sexe : chr \"f\"\n $ age  : num 31\n $ blond: logi TRUE\n\nstr(df[, 2])\n\n num [1:4] 52 31 29 35\n\nstr(df[2])\n\n'data.frame':   4 obs. of  1 variable:\n $ age: num  52 31 29 35\n\nstr(df[[2]])\n\n num [1:4] 52 31 29 35\n\n\ndf[2, ] signifie qu’on veut toutes les variables pour le second individu. Le résultat est un tableau de données à une ligne et trois colonnes. df[2] correspond au mode d’extraction des listes et renvoie donc une liste à un élément, en l’occurrence un tableau de données à quatre observations et une variable. df[[2]] quant à lui renvoie le contenu de cette variable, soit un vecteur numérique de longueur quatre. Reste df[, 2] qui renvoie toutes les observations pour la seconde colonne. Or l’indexation bidimensionnelle a un fonctionnement un peu particulier : par défaut elle renvoie un tableau de données mais s’il y a une seule variable dans l’extraction, c’est un vecteur qui est renvoyé. Pour plus de détails, on pourra consulter l’entrée d’aide help(\"[.data.frame\")."
  },
  {
    "objectID": "rappels/tableaux_donnees.html#afficher-les-données",
    "href": "rappels/tableaux_donnees.html#afficher-les-données",
    "title": "4  Tableaux de données",
    "section": "\n4.3 Afficher les données",
    "text": "4.3 Afficher les données\nPrenons un tableau de données un peu plus conséquent, en l’occurrence le jeu de données ?questionr::hdv2003 disponible dans l’extension questionr et correspondant à un extrait de l’enquête Histoire de vie réalisée par l’INSEE en 2003. Il contient 2000 individus et 20 variables.\n\nlibrary(questionr)\ndata(hdv2003)\n\nSi on demande d’afficher l’objet hdv2003 dans la console (résultat non reproduit ici), R va afficher l’ensemble du contenu de hdv2003 à l’écran ce qui, sur un tableau de cette taille, ne sera pas très lisible. Pour une exploration visuelle, le plus simple est souvent d’utiliser la visionneuse intégrée à RStudio et qu’on peut appeler avec la fonction View().\n\nView(hdv2003)\n\n\n\nFigure 4.1: Interface View() de R RStudio\n\n\nLes fonctions head() et tail(), qui marchent également sur les vecteurs, permettent d’afficher seulement les premières (respectivement les dernières) lignes d’un tableau de données :\n\nhead(hdv2003)\n\n  id age  sexe                                              nivetud    poids\n1  1  28 Femme Enseignement superieur y compris technique superieur 2634.398\n2  2  23 Femme                                                 <NA> 9738.396\n3  3  59 Homme                    Derniere annee d'etudes primaires 3994.102\n4  4  34 Homme Enseignement superieur y compris technique superieur 5731.662\n5  5  71 Femme                    Derniere annee d'etudes primaires 4329.094\n6  6  35 Femme        Enseignement technique ou professionnel court 8674.699\n                  occup     qualif freres.soeurs clso\n1 Exerce une profession    Employe             8  Oui\n2       Etudiant, eleve       <NA>             2  Oui\n3 Exerce une profession Technicien             2  Non\n4 Exerce une profession Technicien             1  Non\n5              Retraite    Employe             0  Oui\n6 Exerce une profession    Employe             5  Non\n                        relig                     trav.imp    trav.satisf\n1 Ni croyance ni appartenance                Peu important Insatisfaction\n2 Ni croyance ni appartenance                         <NA>           <NA>\n3 Ni croyance ni appartenance Aussi important que le reste      Equilibre\n4  Appartenance sans pratique Moins important que le reste   Satisfaction\n5         Pratiquant regulier                         <NA>           <NA>\n6 Ni croyance ni appartenance            Le plus important      Equilibre\n  hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1       Non        Non          Non     Oui    Non    Non   Non         0\n2       Non        Non          Non     Non    Non    Oui   Oui         1\n3       Non        Non          Non     Non    Non    Non   Oui         0\n4       Non        Non          Non     Oui    Oui    Oui   Oui         2\n5       Non        Non          Non     Non    Non    Non   Non         3\n6       Non        Non          Non     Non    Non    Oui   Oui         2\n\ntail(hdv2003, 2)\n\n       id age  sexe                                       nivetud     poids\n1999 1999  24 Femme Enseignement technique ou professionnel court 13740.810\n2000 2000  66 Femme  Enseignement technique ou professionnel long  7709.513\n                     occup  qualif freres.soeurs clso\n1999 Exerce une profession Employe             2  Non\n2000              Au foyer Employe             3  Non\n                          relig                     trav.imp trav.satisf\n1999 Appartenance sans pratique Moins important que le reste   Equilibre\n2000 Appartenance sans pratique                         <NA>        <NA>\n     hard.rock lecture.bd peche.chasse cuisine bricol cinema sport heures.tv\n1999       Non        Non          Non     Non    Non    Oui   Non       0.3\n2000       Non        Oui          Non     Oui    Non    Non   Non       0.0\n\n\nL’extension dplyr propose une fonction dplyr::glimpse() (ce qui signifie aperçu en anglais) qui permet de visualiser rapidement et de manière condensée le contenu d’un tableau de données.\n\nlibrary(dplyr)\nglimpse(hdv2003)\n\nRows: 2,000\nColumns: 20\n$ id            <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1…\n$ age           <int> 28, 23, 59, 34, 71, 35, 60, 47, 20, 28, 65, 47, 63, 67, …\n$ sexe          <fct> Femme, Femme, Homme, Homme, Femme, Femme, Femme, Homme, …\n$ nivetud       <fct> \"Enseignement superieur y compris technique superieur\", …\n$ poids         <dbl> 2634.3982, 9738.3958, 3994.1025, 5731.6615, 4329.0940, 8…\n$ occup         <fct> \"Exerce une profession\", \"Etudiant, eleve\", \"Exerce une …\n$ qualif        <fct> Employe, NA, Technicien, Technicien, Employe, Employe, O…\n$ freres.soeurs <int> 8, 2, 2, 1, 0, 5, 1, 5, 4, 2, 3, 4, 1, 5, 2, 3, 4, 0, 2,…\n$ clso          <fct> Oui, Oui, Non, Non, Oui, Non, Oui, Non, Oui, Non, Oui, O…\n$ relig         <fct> Ni croyance ni appartenance, Ni croyance ni appartenance…\n$ trav.imp      <fct> Peu important, NA, Aussi important que le reste, Moins i…\n$ trav.satisf   <fct> Insatisfaction, NA, Equilibre, Satisfaction, NA, Equilib…\n$ hard.rock     <fct> Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, N…\n$ lecture.bd    <fct> Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, Non, N…\n$ peche.chasse  <fct> Non, Non, Non, Non, Non, Non, Oui, Oui, Non, Non, Non, N…\n$ cuisine       <fct> Oui, Non, Non, Oui, Non, Non, Oui, Oui, Non, Non, Oui, N…\n$ bricol        <fct> Non, Non, Non, Oui, Non, Non, Non, Oui, Non, Non, Oui, O…\n$ cinema        <fct> Non, Oui, Non, Oui, Non, Oui, Non, Non, Oui, Oui, Oui, N…\n$ sport         <fct> Non, Oui, Oui, Oui, Non, Oui, Non, Non, Non, Oui, Non, O…\n$ heures.tv     <dbl> 0.0, 1.0, 0.0, 2.0, 3.0, 2.0, 2.9, 1.0, 2.0, 2.0, 1.0, 0…\n\n\nL’extension labelled propose une fonction labelled::look_for() qui permet de lister les différentes variables d’un fichier de données :\n\nlibrary(labelled)\nlook_for(hdv2003)\n\n pos variable      label col_type values                                     \n 1   id            —     int                                                 \n 2   age           —     int                                                 \n 3   sexe          —     fct      Homme                                      \n                                  Femme                                      \n 4   nivetud       —     fct      N'a jamais fait d'etudes                   \n                                  A arrete ses etudes, avant la derniere ann~\n                                  Derniere annee d'etudes primaires          \n                                  1er cycle                                  \n                                  2eme cycle                                 \n                                  Enseignement technique ou professionnel co~\n                                  Enseignement technique ou professionnel lo~\n                                  Enseignement superieur y compris technique~\n 5   poids         —     dbl                                                 \n 6   occup         —     fct      Exerce une profession                      \n                                  Chomeur                                    \n                                  Etudiant, eleve                            \n                                  Retraite                                   \n                                  Retire des affaires                        \n                                  Au foyer                                   \n                                  Autre inactif                              \n 7   qualif        —     fct      Ouvrier specialise                         \n                                  Ouvrier qualifie                           \n                                  Technicien                                 \n                                  Profession intermediaire                   \n                                  Cadre                                      \n                                  Employe                                    \n                                  Autre                                      \n 8   freres.soeurs —     int                                                 \n 9   clso          —     fct      Oui                                        \n                                  Non                                        \n                                  Ne sait pas                                \n 10  relig         —     fct      Pratiquant regulier                        \n                                  Pratiquant occasionnel                     \n                                  Appartenance sans pratique                 \n                                  Ni croyance ni appartenance                \n                                  Rejet                                      \n                                  NSP ou NVPR                                \n 11  trav.imp      —     fct      Le plus important                          \n                                  Aussi important que le reste               \n                                  Moins important que le reste               \n                                  Peu important                              \n 12  trav.satisf   —     fct      Satisfaction                               \n                                  Insatisfaction                             \n                                  Equilibre                                  \n 13  hard.rock     —     fct      Non                                        \n                                  Oui                                        \n 14  lecture.bd    —     fct      Non                                        \n                                  Oui                                        \n 15  peche.chasse  —     fct      Non                                        \n                                  Oui                                        \n 16  cuisine       —     fct      Non                                        \n                                  Oui                                        \n 17  bricol        —     fct      Non                                        \n                                  Oui                                        \n 18  cinema        —     fct      Non                                        \n                                  Oui                                        \n 19  sport         —     fct      Non                                        \n                                  Oui                                        \n 20  heures.tv     —     dbl                                                 \n\n\nLorsqu’on a un gros tableau de données avec de nombreuses variables, il peut être difficile de retrouver la ou les variables d’intérêt. Il est possible d’indiquer à labelled::look_for() un mot-clé pour limiter la recherche. Par exemple :\n\nlook_for(hdv2003, \"trav\")\n\n pos variable    label col_type values                      \n 11  trav.imp    —     fct      Le plus important           \n                                Aussi important que le reste\n                                Moins important que le reste\n                                Peu important               \n 12  trav.satisf —     fct      Satisfaction                \n                                Insatisfaction              \n                                Equilibre                   \n\n\nIl est à noter que si la recherche n’est pas sensible à la casse (i.e. aux majuscules et aux minuscules), elle est sensible aux accents.\nLa méthode summary() qui fonctionne sur tout type d’objet permet d’avoir quelques statistiques de base sur les différentes variables de notre tableau, les statistiques affichées dépendant du type de variable.\n\nsummary(hdv2003)\n\n       id              age           sexe     \n Min.   :   1.0   Min.   :18.00   Homme: 899  \n 1st Qu.: 500.8   1st Qu.:35.00   Femme:1101  \n Median :1000.5   Median :48.00               \n Mean   :1000.5   Mean   :48.16               \n 3rd Qu.:1500.2   3rd Qu.:60.00               \n Max.   :2000.0   Max.   :97.00               \n                                              \n                                                 nivetud        poids         \n Enseignement technique ou professionnel court       :463   Min.   :   78.08  \n Enseignement superieur y compris technique superieur:441   1st Qu.: 2221.82  \n Derniere annee d'etudes primaires                   :341   Median : 4631.19  \n 1er cycle                                           :204   Mean   : 5535.61  \n 2eme cycle                                          :183   3rd Qu.: 7626.53  \n (Other)                                             :256   Max.   :31092.14  \n NA's                                                :112                     \n                   occup                           qualif    freres.soeurs   \n Exerce une profession:1049   Employe                 :594   Min.   : 0.000  \n Chomeur              : 134   Ouvrier qualifie        :292   1st Qu.: 1.000  \n Etudiant, eleve      :  94   Cadre                   :260   Median : 2.000  \n Retraite             : 392   Ouvrier specialise      :203   Mean   : 3.283  \n Retire des affaires  :  77   Profession intermediaire:160   3rd Qu.: 5.000  \n Au foyer             : 171   (Other)                 :144   Max.   :22.000  \n Autre inactif        :  83   NA's                    :347                   \n          clso                              relig    \n Oui        : 936   Pratiquant regulier        :266  \n Non        :1037   Pratiquant occasionnel     :442  \n Ne sait pas:  27   Appartenance sans pratique :760  \n                    Ni croyance ni appartenance:399  \n                    Rejet                      : 93  \n                    NSP ou NVPR                : 40  \n                                                     \n                         trav.imp           trav.satisf  hard.rock  lecture.bd\n Le plus important           : 29   Satisfaction  :480   Non:1986   Non:1953  \n Aussi important que le reste:259   Insatisfaction:117   Oui:  14   Oui:  47  \n Moins important que le reste:708   Equilibre     :451                        \n Peu important               : 52   NA's          :952                        \n NA's                        :952                                             \n                                                                              \n                                                                              \n peche.chasse cuisine    bricol     cinema     sport        heures.tv     \n Non:1776     Non:1119   Non:1147   Non:1174   Non:1277   Min.   : 0.000  \n Oui: 224     Oui: 881   Oui: 853   Oui: 826   Oui: 723   1st Qu.: 1.000  \n                                                          Median : 2.000  \n                                                          Mean   : 2.247  \n                                                          3rd Qu.: 3.000  \n                                                          Max.   :12.000  \n                                                          NA's   :5       \n\n\nOn peut également appliquer summary() à une variable particulière.\n\nsummary(hdv2003$sexe)\n\nHomme Femme \n  899  1101 \n\nsummary(hdv2003$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  18.00   35.00   48.00   48.16   60.00   97.00"
  },
  {
    "objectID": "rappels/tableaux_donnees.html#en-résumé",
    "href": "rappels/tableaux_donnees.html#en-résumé",
    "title": "4  Tableaux de données",
    "section": "\n4.4 En résumé",
    "text": "4.4 En résumé\n\nLes tableaux de données sont des listes avec des propriétés particulières :\n\ntous les éléments sont des vecteurs ;\ntous les vecteurs ont la même longueur ;\ntous les vecteurs ont un nom et ce nom est unique.\n\n\nOn peut créer un tableau de données avec data.frame().\nLes tableaux de données correspondent aux fichiers de données qu’on utilise usuellement dans d’autres logiciels de statistiques : les variables sont représentées en colonnes et les observations en lignes.\nCe sont des objets bidimensionnels : ncol() renvoie le nombre de colonnes et nrow() le nombre de lignes.\nLes doubles crochets ([[]]) et le symbole dollar ($) fonctionnent comme pour les listes et permettent d’accéder aux variables.\nIl est possible d’utiliser des coordonnées bidimensionnelles avec les crochets simples ([]) en indiquant un critère sur les lignes puis un critère sur les colonnes, séparés par une virgule (,)."
  },
  {
    "objectID": "rappels/tableaux_donnees.html#webin-r",
    "href": "rappels/tableaux_donnees.html#webin-r",
    "title": "4  Tableaux de données",
    "section": "\n4.5 webin-R",
    "text": "4.5 webin-R\nOn pourra également se référer au webin-R #02 (les bases du langage R) sur YouTube."
  }
]