# R√©gression logistique binaire pond√©r√©e {#sec-regression-logistique-binaire-ponderee}

Nous avons abord√© la r√©gression logistique binaire non pond√©r√©e dans un chapitre d√©di√©, cf. @sec-regression-logistique-binaire. Elle se r√©alise classiquement avec la fonction `glm()` en sp√©cifiant `family = binomial`.

Lorsque l'on utilise des donn√©es d'enqu√™tes, l'approche est similaire sauf que l'on aura recours √† la fonction `survey::svyglm()` qui sait g√©rer des objets `{survey}`¬†: non seulement la pond√©ration sera prise en compte, mais le calcul des intervalles de confiance et des p-valeurs sera ajust√© en fonction du plan d'√©chantillonnage.

## Donn√©es des exemples

Nous allons reprendre les m√™me donn√©es issues de l'enqu√™te *Histoire de vie 2003*, mais en tenant compte cette fois-ci des poids de pond√©ration fourni dans la variable *poids*.

```{r}
#| message: false
library(tidyverse)
library(labelled)
data(hdv2003, package = "questionr")
d <-
  hdv2003 |> 
  mutate(
    sexe = sexe |> fct_relevel("Femme"),
    groupe_ages = age |>
      cut(
        c(18, 25, 45, 65, 99),
        right = FALSE,
        include.lowest = TRUE,
        labels = c("18-24 ans", "25-44 ans",
                   "45-64 ans", "65 ans et plus")
      ),
    etudes = nivetud |> 
      fct_recode(
        "Primaire" = "N'a jamais fait d'etudes",
        "Primaire" = "A arrete ses etudes, avant la derniere annee d'etudes primaires",
        "Primaire" = "Derniere annee d'etudes primaires",
        "Secondaire" = "1er cycle",
        "Secondaire" = "2eme cycle",
        "Technique / Professionnel" = "Enseignement technique ou professionnel court",
        "Technique / Professionnel" = "Enseignement technique ou professionnel long",
        "Sup√©rieur" = "Enseignement superieur y compris technique superieur"
    ) |> 
    fct_na_value_to_level("Non document√©")  
  ) |> 
  set_variable_labels(
    sport = "Pratique un sport ?",
    sexe = "Sexe",
    groupe_ages = "Groupe d'√¢ges",
    etudes = "Niveau d'√©tudes",
    relig = "Rapport √† la religion",
    heures.tv = "Heures de t√©l√©vision / jour",
    poids = "Pond√©ration de l'enqu√™te"
  )
```

Il ne nous reste qu'√† d√©finir notre objet `{survey}` en sp√©cifiant la pond√©ration fournie avec l'enqu√™te. La documentation ne mentionne ni strates ni grappes.

```{r}
#| message: false
library(srvyr)
library(survey)
dp <- d |> 
  as_survey_design(weights = poids)
```

## Calcul de la r√©gression logistique binaire

La syntaxe de `survey::svyglm()` est similaire √† celle de `glm()` sauf qu'elle a un argument `design` au lieu de `data`.

La plupart du temps, les poids de pond√©ration ne sont pas des nombres entiers, mais des nombres d√©cimaux. Or, la famille de mod√®les binomiaux repose sur des nombres entiers de succ√®s et d'√©checs. Avec une version r√©cente[^regression-logistique-binaire-ponderee-1] de **R**, cela n'est pas probl√©matique. Nous aurons simplement un avertissement.

[^regression-logistique-binaire-ponderee-1]: Si vous utilisez une version ancienne de **R**, cela n'√©tait tout simplement pas possible. Vous obteniez un message d'erreur et le mod√®le n'√©tait pas calcul√©. Si c'est votre cas, optez pour un mod√®le quasi-binomial ou bien mettez √† jour **R.**

```{r}
mod_binomial <- svyglm(
  sport ~ sexe + groupe_ages + etudes + relig + heures.tv,
  family = binomial,
  design = dp
)
```

Une alternative consiste √† avoir recours √† la famille quasi-binomiale, que l'on sp√©cifie avec `family = quasibinomial` et qui constitue une extension de la famille binomiale pouvant g√©rer des poids non entiers. La distribution quasi-binomiale, bien que similaire √† la distribution binomiale, poss√®de un param√®tre suppl√©mentaire ùúô qui tente de d√©crire une variance suppl√©mentaire dans les donn√©es qui ne peut √™tre expliqu√©e par une distribution binomiale seule (on parle alors de *surdispersion*). Les coefficients obtenus sont les m√™mes, mais les intervalles de confiance peuvent √™tre un peu plus large.

```{r}
mod_quasi <- svyglm(
  sport ~ sexe + groupe_ages + etudes + relig + heures.tv,
  family = quasibinomial,
  design = dp
)
```

Simple, non¬†?

## S√©lection de mod√®le

Comme pr√©c√©demment, il est possible de proc√©der √† une s√©lection de mod√®le pas √† pas, par minimisation de l'AIC, avec `step()`.

```{r}
mod_quasi2 <- step(mod_quasi)
```

::: callout-warning
## S√©lection pas √† pas et valeurs manquantes

Nous avons abord√© dans le chapitre sur la r√©gression logistique binaire la probl√©matique des valeurs manquantes lors d'une s√©lection pas √† pas descendante par minimisation de l'AIC (cf. encadr√© de la @sec-step ). La m√™me approche peut √™tre appliqu√©e avec des donn√©es pond√©r√©es. Cependant, la fonction `step_with_na()` que nous avons pr√©sent√© n'est pas compatible avec les mod√®les `survey::svyglm()` puisqu'ils prennent en entr√©e un argument `design` et non `data`.

On pourra essayer la variante `step_with_na_survey()` ci-dessous qui n√©cessite qu'on lui passe √©galement l'objet `{survey}` ayant servi au calcul du mod√®le.

```{r}
step_with_na_survey <- function(model, design, ...) {
  # list of variables
  variables <- broom.helpers::model_list_variables(
    model,
    only_variable = TRUE
  )
  # design with no na
  design_no_na <- design |> 
    srvyr::drop_na(dplyr::any_of(variables))
  # refit the model without NAs
  model_no_na <- update(model, data = design_no_na)  
  # apply step()
  model_simplified <- step(model_no_na, ...)
  # recompute simplified model using full data
  update(model, formula = terms(model_simplified))
}
```

```{r}
#| eval: false
mod2_binomial <- step_with_na_survey(mod_binomial, dp)
```
:::

## Affichage des r√©sultats

Nous pouvons tout √† fait utiliser `gtsumarry::tbl_regression()` avec ce type de mod√®les. De m√™me, on peut utiliser `gtsummary::add_global_p()` pour calculer les p-valeurs globales des variables ou encore `gtsummary::add_vif()` pour v√©rifier la multicolin√©arit√© (cf. @sec-multicolinearite).

```{r}
#| message: false
library(gtsummary)
theme_gtsummary_language("fr", decimal.mark = ",", big.mark = " ")
```

```{r}
#| label: tbl-regression-logistique-ponderee
#| tbl-cap: Facteurs associ√©s √† la pratique d'un sport (r√©gression logistique pond√©r√©e)
mod_quasi2 |> 
  tbl_regression(exponentiate = TRUE) |> 
  add_global_p(keep = TRUE) |> 
  add_vif() |> 
  bold_labels()
```

Pour un graphique des coefficients, nous pouvons utiliser `ggstats::ggcoef_model()`.

```{r}
#| label: fig-forest-plot-regression-logistique-ponderee
#| fig-cap: Facteurs associ√©s √† la pratique d'un sport (r√©gression logistique pond√©r√©e)
mod_quasi2 |> 
  ggstats::ggcoef_model(exponentiate = TRUE)
```

## Pr√©dictions marginales

Pour visualiser les pr√©dictions marginales moyennes du mod√®le (cf. @sec-predictions-marginales), nous pouvons utiliser `broom.helpers::plot_marginal_predictions()`.

```{r}
#| label: fig-predictions-marginales-moyennes-regression-ponderee
#| fig-cap: Pr√©dictions marginales moyennes du mod√®le pond√©r√©
mod_quasi2 |> 
  broom.helpers::plot_marginal_predictions(type = "response") |> 
  patchwork::wrap_plots() &
  scale_y_continuous(
    limits = c(0, .8),
    labels = scales::label_percent()
  )
```
